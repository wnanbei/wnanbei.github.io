<!doctype html><html lang=zh-cn>
<head><meta charset=utf-8>
<meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="Go 中的net包封装了大部分网络相关的功能，我们基本不需要借助其他库就能实现我们的爬虫需求。
"><title>Go net/http client 客户端</title>
<link rel=canonical href=https://wnanbei.github.io/post/go-net/http-client-%E5%AE%A2%E6%88%B7%E7%AB%AF/>
<link rel=stylesheet href=/scss/style.min.css><meta property="og:title" content="Go net/http client 客户端">
<meta property="og:description" content="Go 中的net包封装了大部分网络相关的功能，我们基本不需要借助其他库就能实现我们的爬虫需求。
">
<meta property="og:url" content="https://wnanbei.github.io/post/go-net/http-client-%E5%AE%A2%E6%88%B7%E7%AB%AF/">
<meta property="og:site_name" content="WNANBEI">
<meta property="og:type" content="article"><meta property="article:section" content="Post"><meta property="article:tag" content="Go"><meta property="article:published_time" content="2019-01-01T00:00:00+00:00"><meta property="article:modified_time" content="2021-11-09T23:34:24+08:00">
<meta name=twitter:title content="Go net/http client 客户端">
<meta name=twitter:description content="Go 中的net包封装了大部分网络相关的功能，我们基本不需要借助其他库就能实现我们的爬虫需求。
">
<link rel="shortcut icon" href=images/avatar.jpg>
</head>
<body class="article-page has-toc">
<script>(function(){const a='StackColorScheme';localStorage.getItem(a)||localStorage.setItem(a,"auto")})()</script><script>(function(){const b='StackColorScheme',a=localStorage.getItem(b),c=window.matchMedia('(prefers-color-scheme: dark)').matches===!0;a=='dark'||a==='auto'&&c?document.documentElement.dataset.scheme='dark':document.documentElement.dataset.scheme='light'})()</script>
<div class="container main-container flex
extended">
<div id=article-toolbar>
<a href=/ class=back-home><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-chevron-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><polyline points="15 6 9 12 15 18"/></svg>
<span>返回</span>
</a>
</div>
<main class="main full-width">
<article class=main-article>
<header class=article-header>
<div class=article-details>
<header class=article-category>
<a href=/categories/go%E6%A0%87%E5%87%86%E5%BA%93/>
Go标准库
</a>
</header>
<h2 class=article-title>
<a href=/post/go-net/http-client-%E5%AE%A2%E6%88%B7%E7%AB%AF/>Go net/http client 客户端</a>
</h2>
<footer class=article-time>
<div><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M11.795 21H5a2 2 0 01-2-2V7a2 2 0 012-2h12a2 2 0 012 2v4"/><circle cx="18" cy="18" r="4"/><path d="M15 3v4"/><path d="M7 3v4"/><path d="M3 11h16"/><path d="M18 16.496V18l1 1"/></svg>
<time class=article-time--published>2019-01-01</time>
</div>
<div><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg>
<time class=article-time--reading>
阅读时长: 10 分钟
</time>
</div>
</footer>
</div>
</header>
<section class=article-content>
<p>Go 中的<code>net</code>包封装了大部分网络相关的功能，我们基本不需要借助其他库就能实现我们的爬虫需求。</p>
<h2 id=简单请求>简单请求</h2>
<p>其中最为常用的是 <code>http</code> 和 <code>url</code>，使用前可以根据我们的需要进行导入：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#f92672>import</span> (
	<span style=color:#e6db74>&#34;net/http&#34;</span>
	<span style=color:#e6db74>&#34;net/url&#34;</span>
)
</code></pre></div><p><code>http</code>提供了一些非常方便的接口，可以实现最简单的请求，例如Get、Post、Head：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#a6e22e>resp</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>Get</span>(<span style=color:#e6db74>&#34;http://example.com/&#34;</span>)
<span style=color:#f92672>...</span>
<span style=color:#a6e22e>resp</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>Post</span>(<span style=color:#e6db74>&#34;http://example.com/upload&#34;</span>, <span style=color:#e6db74>&#34;image/jpeg&#34;</span>, <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>buf</span>)
<span style=color:#f92672>...</span>
<span style=color:#a6e22e>resp</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>PostForm</span>(<span style=color:#e6db74>&#34;http://example.com/form&#34;</span>,
	<span style=color:#a6e22e>url</span>.<span style=color:#a6e22e>Values</span>{<span style=color:#e6db74>&#34;key&#34;</span>: {<span style=color:#e6db74>&#34;Value&#34;</span>}, <span style=color:#e6db74>&#34;id&#34;</span>: {<span style=color:#e6db74>&#34;123&#34;</span>}})
</code></pre></div><p>可以看到，我们非常简单的就发起了请求并获得了响应，这里需要注意一点的是，获得的响应body需要我们手动关闭：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#a6e22e>resp</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>Get</span>(<span style=color:#e6db74>&#34;http://example.com/&#34;</span>)
<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
	<span style=color:#75715e>// 处理异常
</span><span style=color:#75715e></span>}
<span style=color:#66d9ef>defer</span> <span style=color:#a6e22e>resp</span>.<span style=color:#a6e22e>Body</span>.<span style=color:#a6e22e>Close</span>()  <span style=color:#75715e>// 函数结束时关闭Body
</span><span style=color:#75715e></span><span style=color:#a6e22e>body</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>ioutil</span>.<span style=color:#a6e22e>ReadAll</span>(<span style=color:#a6e22e>resp</span>.<span style=color:#a6e22e>Body</span>)  <span style=color:#75715e>// 读取Body
</span><span style=color:#75715e>// ...
</span></code></pre></div><p>这样的请求方式是非常方便的，但是当我们需要定制我们请求的其他参数时，就必须要使用其他组件了。</p>
<h2 id=client>Client</h2>
<p><code>Client</code>是<code>http</code>包内部发起请求的组件，使用它，我们才可以去控制请求的超时、重定向和其他的设置。以下是Client的定义：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Client</span> <span style=color:#66d9ef>struct</span> {
	<span style=color:#a6e22e>Transport</span>     <span style=color:#a6e22e>RoundTripper</span>
	<span style=color:#a6e22e>CheckRedirect</span> <span style=color:#66d9ef>func</span>(<span style=color:#a6e22e>req</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>Request</span>, <span style=color:#a6e22e>via</span> []<span style=color:#f92672>*</span><span style=color:#a6e22e>Request</span>) <span style=color:#66d9ef>error</span>
	<span style=color:#a6e22e>Jar</span>           <span style=color:#a6e22e>CookieJar</span>
	<span style=color:#a6e22e>Timeout</span>       <span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Duration</span> <span style=color:#75715e>// Go 1.3
</span><span style=color:#75715e></span>}
</code></pre></div><p>首先是生成Client对象：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#a6e22e>client</span> <span style=color:#f92672>:=</span> <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>Client</span>{}
</code></pre></div><p>Client也有一些简便的请求方法，如：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#a6e22e>resp</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>client</span>.<span style=color:#a6e22e>Get</span>(<span style=color:#e6db74>&#34;http://example.com&#34;</span>)
</code></pre></div><p>但这种方法与直接使用<code>http.Get</code>没多大差别，我们需要使用另一个方法来定制请求的Header、请求体、证书验证等参数，这就是<code>Request</code>和<code>Do</code>。</p>
<h3 id=设置超时>设置超时</h3>
<p>这是一张说明Client超时的控制范围的图：</p>
<p><figure>
<a href=/assets/client-timeout.png>
<img src=/assets/client-timeout.png loading=lazy alt=img>
</a>
<figcaption>img</figcaption>
</figure></p>
<p>这其中，设置起来最方便的是<code>http.Client.Timeout</code>，可以在创建Client时通过字段设置，其计算的范围包括连接(Dial)到读完response body为止。</p>
<p><code>http.Client</code>会自动跟随重定向，重定向时间也会记入<code>http.Client.Timeout</code>，这点一定要注意。</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#a6e22e>client</span> <span style=color:#f92672>:=</span> <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>Client</span>{
    <span style=color:#a6e22e>Timeout</span>: <span style=color:#ae81ff>15</span> <span style=color:#f92672>*</span> <span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Second</span>
}
</code></pre></div><p>还有一些更细粒度的超时控制：</p>
<ul>
<li><code>net.Dialer.Timeout</code> 限制建立TCP连接的时间</li>
<li><code>http.Transport.TLSHandshakeTimeout</code> 限制 TLS握手的时间</li>
<li><code>http.Transport.ResponseHeaderTimeout</code> 限制读取response header的时间</li>
<li><code>http.Transport.ExpectContinueTimeout</code> 限制client在发送包含 <code>Expect: 100-continue</code>的header到收到继续发送body的response之间的时间等待。</li>
</ul>
<p>如果需要使用这些超时，需要到<code>Transport</code>中去设置，方法如下所示：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#a6e22e>c</span> <span style=color:#f92672>:=</span> <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>Client</span>{  
    <span style=color:#a6e22e>Transport</span>: <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>Transport</span>{
        <span style=color:#a6e22e>DialContext</span>: (<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>net</span>.<span style=color:#a6e22e>Dialer</span>{
                <span style=color:#a6e22e>Timeout</span>:   <span style=color:#ae81ff>30</span> <span style=color:#f92672>*</span> <span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Second</span>,
                <span style=color:#a6e22e>KeepAlive</span>: <span style=color:#ae81ff>30</span> <span style=color:#f92672>*</span> <span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Second</span>,
        }).<span style=color:#a6e22e>DialContext</span>,
        <span style=color:#a6e22e>TLSHandshakeTimeout</span>:   <span style=color:#ae81ff>10</span> <span style=color:#f92672>*</span> <span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Second</span>,
        <span style=color:#a6e22e>ResponseHeaderTimeout</span>: <span style=color:#ae81ff>10</span> <span style=color:#f92672>*</span> <span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Second</span>,
        <span style=color:#a6e22e>ExpectContinueTimeout</span>: <span style=color:#ae81ff>1</span> <span style=color:#f92672>*</span> <span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Second</span>,
    },
}
</code></pre></div><p>可以看到这其中没有单独控制<code>Do</code>方法超时时间的设置，如果需要的话可以使用<code>context</code>自行实现。</p>
<h3 id=控制重定向>控制重定向</h3>
<p>在Client的字段中，有一个<code>CheckRedirect</code>，此字段就是用来控制重定向的函数，如果没有定义此字段的话，将会使用默认的<code>defaultCheckRedirect</code>方法。</p>
<p>默认的转发策略是最多转发10次。</p>
<p>在转发的过程中，某一些包含安全信息的Header，比如<code>Authorization</code>、<code>WWW-Authenticate</code>、<code>Cookie</code>等，如果转发是跨域的，那么这些Header不会复制到新的请求中。</p>
<p><code>http</code>的重定向判断会默认处理以下状态码的请求：</p>
<ul>
<li>301 (Moved Permanently)</li>
<li>302 (Found)</li>
<li>303 (See Other)</li>
<li>307 (Temporary Redirect)</li>
<li>308 (Permanent Redirect)</li>
</ul>
<p>301、302和303请求将会改用Get访问新的请求，而307和308会使用原有的请求方式。</p>
<p>那么，我们如何去控制重定向的次数，甚至是禁止重定向呢？这里其实就需要我们自己去实现一个<code>CheckRedirect</code>函数了，首先我们来看看默认的<code>defaultCheckRedirect</code>方法：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>defaultCheckRedirect</span>(<span style=color:#a6e22e>req</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>Request</span>, <span style=color:#a6e22e>via</span> []<span style=color:#f92672>*</span><span style=color:#a6e22e>Request</span>) <span style=color:#66d9ef>error</span> {
	<span style=color:#66d9ef>if</span> len(<span style=color:#a6e22e>via</span>) <span style=color:#f92672>&gt;=</span> <span style=color:#ae81ff>10</span> {
		<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>errors</span>.<span style=color:#a6e22e>New</span>(<span style=color:#e6db74>&#34;stopped after 10 redirects&#34;</span>)
	}
	<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>nil</span>
}
</code></pre></div><p>第一个参数<code>req</code>是即将转发的request，第二个参数 <code>via</code>是已经请求过的requests。可以看到其中的逻辑是判断请求过的request数量，大于等于10的时候返回一个<code>error</code>，这也说明默认的最大重定向次数为10次，当此函数返回<code>error</code>时，即是重定向结束的时候。</p>
<p>所以如果需要设置重定向次数，那么复制一份这个函数，修改函数名字和其中if判断的数字，然后在生成Client时设定到Client即可：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#a6e22e>client</span> <span style=color:#f92672>:=</span> <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>Client</span>{
    <span style=color:#a6e22e>CheckRedirect</span>: <span style=color:#a6e22e>yourCheckRedirect</span>,
}
</code></pre></div><p>或者：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#a6e22e>client</span> <span style=color:#f92672>:=</span> <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>Client</span>{}
<span style=color:#a6e22e>client</span>.<span style=color:#a6e22e>CheckRedirect</span> = <span style=color:#a6e22e>yourCheckRedirect</span>
</code></pre></div><p>禁止重定向则可以把判断数字修改为0。最好相应地修改errors中提示的信息。</p>
<h3 id=cookiejar管理>CookieJar管理</h3>
<p>可以看到Client结构体中还有一个<code>Jar</code>字段，类型为<code>CookieJar</code>，这是Client用来管理Cookie的对象。</p>
<p>如果在生成Client时，没有给这个字段赋值，使其为<code>nil</code>的话，那么之后Client发起的请求将只会带上Request对象中指定的Cookie，请求响应中由服务器返回的Cookie也不会被保存。所以如果需要自动管理Cookie的话，我们还需要生成并设定一个CookieJar对象：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#a6e22e>options</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>cookiejar</span>.<span style=color:#a6e22e>Options</span>{
    <span style=color:#a6e22e>PublicSuffixList</span>: <span style=color:#a6e22e>publicsuffix</span>.<span style=color:#a6e22e>List</span>
}
<span style=color:#a6e22e>jar</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>cookiejar</span>.<span style=color:#a6e22e>New</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>options</span>)
<span style=color:#a6e22e>client</span> <span style=color:#f92672>:=</span> <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>Client</span>{
    <span style=color:#a6e22e>Jar</span>: <span style=color:#a6e22e>jar</span>,
}
</code></pre></div><p>这里的<code>publicsuffix.List</code>是一个域的公共后缀列表，是一个可选的选项，设置为<code>nil</code>代表不启用。但是不启用的情况下会使Cookie变得不安全：意味着foo.com的HTTP服务器可以为bar.com设置cookie。所以一般来说最好启用。</p>
<p>如果嫌麻烦不想启用<code>PublicSuffixList</code>，可以将其设置为<code>nil</code>，如下即可：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#a6e22e>jar</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>cookiejar</span>.<span style=color:#a6e22e>New</span>(<span style=color:#66d9ef>nil</span>)
<span style=color:#a6e22e>client</span> <span style=color:#f92672>:=</span> <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>Client</span>{
    <span style=color:#a6e22e>Jar</span>: <span style=color:#a6e22e>jar</span>,
}
</code></pre></div><p>而<code>publicsuffix.List</code>的实现位于golang.org/x/net/publicsuffix，需要额外下载，使用的时候也需要导入：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#f92672>import</span> <span style=color:#e6db74>&#34;golang.org/x/net/publicsuffix&#34;</span>
</code></pre></div><h2 id=request>Request</h2>
<p>这是Go源码中Request定义的字段，可以看到非常的多，有兴趣的可以去源码或者官方文档看有注释的版本，本文只介绍一些比较重要的字段。</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Request</span> <span style=color:#66d9ef>struct</span> {
	<span style=color:#a6e22e>Method</span>           <span style=color:#66d9ef>string</span>
	<span style=color:#a6e22e>URL</span>              <span style=color:#f92672>*</span><span style=color:#a6e22e>url</span>.<span style=color:#a6e22e>URL</span>
	<span style=color:#a6e22e>Proto</span>            <span style=color:#66d9ef>string</span> <span style=color:#75715e>// &#34;HTTP/1.0&#34;
</span><span style=color:#75715e></span>	<span style=color:#a6e22e>ProtoMajor</span>       <span style=color:#66d9ef>int</span>    <span style=color:#75715e>// 1
</span><span style=color:#75715e></span>	<span style=color:#a6e22e>ProtoMinor</span>       <span style=color:#66d9ef>int</span>    <span style=color:#75715e>// 0
</span><span style=color:#75715e></span>	<span style=color:#a6e22e>Header</span>           <span style=color:#a6e22e>Header</span>
	<span style=color:#a6e22e>Body</span>             <span style=color:#a6e22e>io</span>.<span style=color:#a6e22e>ReadCloser</span>
	<span style=color:#a6e22e>GetBody</span>          <span style=color:#66d9ef>func</span>() (<span style=color:#a6e22e>io</span>.<span style=color:#a6e22e>ReadCloser</span>, <span style=color:#66d9ef>error</span>)
	<span style=color:#a6e22e>ContentLength</span>    <span style=color:#66d9ef>int64</span>
	<span style=color:#a6e22e>TransferEncoding</span> []<span style=color:#66d9ef>string</span>
	<span style=color:#a6e22e>Close</span>            <span style=color:#66d9ef>bool</span>
	<span style=color:#a6e22e>Host</span>             <span style=color:#66d9ef>string</span>
	<span style=color:#a6e22e>Form</span>             <span style=color:#a6e22e>url</span>.<span style=color:#a6e22e>Values</span>
	<span style=color:#a6e22e>PostForm</span>         <span style=color:#a6e22e>url</span>.<span style=color:#a6e22e>Values</span>
	<span style=color:#a6e22e>MultipartForm</span>    <span style=color:#f92672>*</span><span style=color:#a6e22e>multipart</span>.<span style=color:#a6e22e>Form</span>
	<span style=color:#a6e22e>Trailer</span>          <span style=color:#a6e22e>Header</span>
	<span style=color:#a6e22e>RemoteAddr</span>       <span style=color:#66d9ef>string</span>
	<span style=color:#a6e22e>RequestURI</span>       <span style=color:#66d9ef>string</span>
	<span style=color:#a6e22e>TLS</span>              <span style=color:#f92672>*</span><span style=color:#a6e22e>tls</span>.<span style=color:#a6e22e>ConnectionState</span>
	<span style=color:#a6e22e>Cancel</span>           <span style=color:#f92672>&lt;-</span><span style=color:#66d9ef>chan</span> <span style=color:#66d9ef>struct</span>{}
	<span style=color:#a6e22e>Response</span>         <span style=color:#f92672>*</span><span style=color:#a6e22e>Response</span>
}
</code></pre></div><p>在这里不推荐直接生成Request，而应该使用http提供的<code>NewRequest</code>方法来生成Request，此方法中做了一些生成Request的默认设置，以下是<code>NewRequest</code>的函数签名：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>NewRequest</span>(<span style=color:#a6e22e>method</span>, <span style=color:#a6e22e>url</span> <span style=color:#66d9ef>string</span>, <span style=color:#a6e22e>body</span> <span style=color:#a6e22e>io</span>.<span style=color:#a6e22e>Reader</span>) (<span style=color:#f92672>*</span><span style=color:#a6e22e>Request</span>, <span style=color:#66d9ef>error</span>)
</code></pre></div><p>参数中<code>method</code>和<code>url</code>两个是必备参数，而<code>body</code>参数，在使用没有body的请求方法时，传入<code>nil</code>即可。</p>
<p>配置好Request之后，使用Client对象的<code>Do</code>方法，就可以将Request发送出去，以下是示例：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#a6e22e>req</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>NewRequest</span>(<span style=color:#e6db74>&#34;GET&#34;</span>, <span style=color:#e6db74>&#34;https://www.baidu.com&#34;</span>, <span style=color:#66d9ef>nil</span>)
<span style=color:#a6e22e>resp</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>client</span>.<span style=color:#a6e22e>Do</span>(<span style=color:#a6e22e>req</span>)
</code></pre></div><h3 id=method>Method</h3>
<p>请求方法，必备的参数，如果为空字符则表示Get请求。</p>
<p>注：Go的HTTP客户端不支持<code>CONNECT</code>请求方法。</p>
<h3 id=url>URL</h3>
<p>一个被解析过的url结构体。</p>
<h3 id=proto>Proto</h3>
<p>HTTP协议版本。</p>
<p>在Go中，HTTP请求会默认使用<code>HTTP1.1</code>，而HTTPS请求会默认首先使用<code>HTTP2.0</code>，如果目标服务器不支持，握手失败后才会改用<code>HTTP1.1</code>。</p>
<p>如果希望强制使用<code>HTTP2.0</code>的协议，那么需要使用<code>golang.org/x/net/http2</code>这个包所提供的功能。</p>
<h3 id=发起post请求>发起Post请求</h3>
<p>如果要使用Request发起Post请求，提交表单的话，可以用到它的<code>PostForm</code>字段，这是一个类型为<code>url.Values</code>的字段，以下为示例：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#a6e22e>req</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>NewRequest</span>(<span style=color:#e6db74>&#34;Post&#34;</span>, <span style=color:#e6db74>&#34;https://www.baidu.com&#34;</span>, <span style=color:#66d9ef>nil</span>)
<span style=color:#a6e22e>req</span>.<span style=color:#a6e22e>PostForm</span>.<span style=color:#a6e22e>Add</span>(<span style=color:#e6db74>&#34;key&#34;</span>, <span style=color:#e6db74>&#34;value&#34;</span>)
</code></pre></div><p>如果你Post提交的不是表单数据，那么你需要将其封装成<code>io.Reader</code>类型，并在<code>NewRequest</code>函数中传递进去。</p>
<h3 id=设置header>设置Header</h3>
<p>Header的类型是<code>http.Header</code>，其中包含着之前请求中返回的header和client发送的header。</p>
<p>可以使用这种方式设置Header：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#a6e22e>req</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>NewRequest</span>(<span style=color:#e6db74>&#34;Get&#34;</span>, <span style=color:#e6db74>&#34;https://www.baidu.com&#34;</span>, <span style=color:#66d9ef>nil</span>)
<span style=color:#a6e22e>req</span>.<span style=color:#a6e22e>Header</span>.<span style=color:#a6e22e>Add</span>(<span style=color:#e6db74>&#34;key&#34;</span>, <span style=color:#e6db74>&#34;value&#34;</span>)
</code></pre></div><p>Header还有一些<code>Set</code>、<code>Del</code>等方法可以使用。</p>
<h3 id=添加cookie>添加Cookie</h3>
<p>前文我们已经介绍了如何在Client中启用一直使用的CookieJar，使用它可以自动管理获得的Cookie。</p>
<p>但很多时候我们也需要给特定的请求手动设置Cookie，这个时候就可以使用Request对象的<code>AddCookie</code>方法，这是其函数签名：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>r</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>Request</span>) <span style=color:#a6e22e>AddCookie</span>(<span style=color:#a6e22e>c</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>Cookie</span>)
</code></pre></div><p>要注意的是，其传入的参数是Cookie类型，，以下是此类型包含的属性：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Cookie</span> <span style=color:#66d9ef>struct</span> {
    <span style=color:#a6e22e>Name</span>       <span style=color:#66d9ef>string</span>
    <span style=color:#a6e22e>Value</span>      <span style=color:#66d9ef>string</span>
    <span style=color:#a6e22e>Path</span>       <span style=color:#66d9ef>string</span>
    <span style=color:#a6e22e>Domain</span>     <span style=color:#66d9ef>string</span>
    <span style=color:#a6e22e>Expires</span>    <span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Time</span>
    <span style=color:#a6e22e>RawExpires</span> <span style=color:#66d9ef>string</span>
    <span style=color:#a6e22e>MaxAge</span>     <span style=color:#66d9ef>int</span>
    <span style=color:#a6e22e>Secure</span>     <span style=color:#66d9ef>bool</span>
    <span style=color:#a6e22e>HttpOnly</span>   <span style=color:#66d9ef>bool</span>
    <span style=color:#a6e22e>Raw</span>        <span style=color:#66d9ef>string</span>
    <span style=color:#a6e22e>Unparsed</span>   []<span style=color:#66d9ef>string</span>
}
</code></pre></div><p>其中只有<code>Name</code>和<code>Value</code>是必须的，所以以下是添加Cookie的示例：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#a6e22e>c</span> <span style=color:#f92672>:=</span> <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>Cookie</span>{
    <span style=color:#a6e22e>Name</span>:  <span style=color:#e6db74>&#34;key&#34;</span>,
    <span style=color:#a6e22e>Value</span>: <span style=color:#e6db74>&#34;value&#34;</span>,
}
<span style=color:#a6e22e>req</span>.<span style=color:#a6e22e>AddCookie</span>(<span style=color:#a6e22e>c</span>)
</code></pre></div><h2 id=transport>Transport</h2>
<p><code>Transport</code>是<code>Client</code>中的一个类型，用于控制传输过程，是Client实际发起请求的底层实现。如果没有给这个字段初始化相应的值，那么将会使用默认的<code>DefaultTransport</code>。</p>
<p>Transport承担起了Client中连接池的功能，它会将建立的连接缓存下来，这可能会在访问大量不同网站时，留下太多打开的连接，这可以使用Transport中的方法进行关闭。</p>
<p>首先来看一下<code>Transport</code>的定义：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Transport</span> <span style=color:#66d9ef>struct</span> {
	<span style=color:#a6e22e>Proxy</span>                  <span style=color:#66d9ef>func</span>(<span style=color:#f92672>*</span><span style=color:#a6e22e>Request</span>) (<span style=color:#f92672>*</span><span style=color:#a6e22e>url</span>.<span style=color:#a6e22e>URL</span>, <span style=color:#66d9ef>error</span>)
	<span style=color:#a6e22e>DialContext</span>            <span style=color:#66d9ef>func</span>(<span style=color:#a6e22e>ctx</span> <span style=color:#a6e22e>context</span>.<span style=color:#a6e22e>Context</span>, <span style=color:#a6e22e>network</span>, <span style=color:#a6e22e>addr</span> <span style=color:#66d9ef>string</span>) (<span style=color:#a6e22e>net</span>.<span style=color:#a6e22e>Conn</span>, <span style=color:#66d9ef>error</span>) <span style=color:#75715e>// Go 1.7
</span><span style=color:#75715e></span>	<span style=color:#a6e22e>Dial</span>                   <span style=color:#66d9ef>func</span>(<span style=color:#a6e22e>network</span>, <span style=color:#a6e22e>addr</span> <span style=color:#66d9ef>string</span>) (<span style=color:#a6e22e>net</span>.<span style=color:#a6e22e>Conn</span>, <span style=color:#66d9ef>error</span>)
	<span style=color:#a6e22e>DialTLS</span>                <span style=color:#66d9ef>func</span>(<span style=color:#a6e22e>network</span>, <span style=color:#a6e22e>addr</span> <span style=color:#66d9ef>string</span>) (<span style=color:#a6e22e>net</span>.<span style=color:#a6e22e>Conn</span>, <span style=color:#66d9ef>error</span>) <span style=color:#75715e>// Go 1.4
</span><span style=color:#75715e></span>	<span style=color:#a6e22e>TLSClientConfig</span>        <span style=color:#f92672>*</span><span style=color:#a6e22e>tls</span>.<span style=color:#a6e22e>Config</span>
	<span style=color:#a6e22e>TLSHandshakeTimeout</span>    <span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Duration</span> <span style=color:#75715e>// Go 1.3
</span><span style=color:#75715e></span>	<span style=color:#a6e22e>DisableKeepAlives</span>      <span style=color:#66d9ef>bool</span>
	<span style=color:#a6e22e>DisableCompression</span>     <span style=color:#66d9ef>bool</span>
	<span style=color:#a6e22e>MaxIdleConns</span>           <span style=color:#66d9ef>int</span> <span style=color:#75715e>// Go 1.7
</span><span style=color:#75715e></span>	<span style=color:#a6e22e>MaxIdleConnsPerHost</span>    <span style=color:#66d9ef>int</span>
	<span style=color:#a6e22e>MaxConnsPerHost</span>        <span style=color:#66d9ef>int</span>                                                         <span style=color:#75715e>// Go 1.11
</span><span style=color:#75715e></span>	<span style=color:#a6e22e>IdleConnTimeout</span>        <span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Duration</span>                                               <span style=color:#75715e>// Go 1.7
</span><span style=color:#75715e></span>	<span style=color:#a6e22e>ResponseHeaderTimeout</span>  <span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Duration</span>                                               <span style=color:#75715e>// Go 1.1
</span><span style=color:#75715e></span>	<span style=color:#a6e22e>ExpectContinueTimeout</span>  <span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Duration</span>                                               <span style=color:#75715e>// Go 1.6
</span><span style=color:#75715e></span>	<span style=color:#a6e22e>TLSNextProto</span>           <span style=color:#66d9ef>map</span>[<span style=color:#66d9ef>string</span>]<span style=color:#66d9ef>func</span>(<span style=color:#a6e22e>authority</span> <span style=color:#66d9ef>string</span>, <span style=color:#a6e22e>c</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>tls</span>.<span style=color:#a6e22e>Conn</span>) <span style=color:#a6e22e>RoundTripper</span> <span style=color:#75715e>// Go 1.6
</span><span style=color:#75715e></span>	<span style=color:#a6e22e>ProxyConnectHeader</span>     <span style=color:#a6e22e>Header</span>                                                      <span style=color:#75715e>// Go 1.8
</span><span style=color:#75715e></span>	<span style=color:#a6e22e>MaxResponseHeaderBytes</span> <span style=color:#66d9ef>int64</span>                                                       <span style=color:#75715e>// Go 1.7
</span><span style=color:#75715e></span>}
</code></pre></div><p>由于<code>Transport</code>是<code>Client</code>内部请求的实际发起者，所以内容会比较多，1.6之后的版本也添加了许多新的字段，这里我们来讲解常见的一些字段。</p>
<h3 id=拨号>拨号</h3>
<p>由于Client中设置的Timeout范围比较宽，而在生产环境中我们可能需要更为精细的超时控制，在<code>Dial</code>拨号中可以设置几个超时时间。</p>
<p>在较新的版本中，<code>Dial</code>这个字段已经不再被推荐使用，取而代之的是<code>DialContext</code>，设置这个字段，需要借助于<code>net.Dialer</code>，以下是其定义：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Dialer</span> <span style=color:#66d9ef>struct</span> {
	<span style=color:#a6e22e>Timeout</span> <span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Duration</span>
	<span style=color:#a6e22e>Deadline</span> <span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Time</span>
	<span style=color:#a6e22e>LocalAddr</span> <span style=color:#a6e22e>Addr</span>
	<span style=color:#a6e22e>DualStack</span> <span style=color:#66d9ef>bool</span>
	<span style=color:#a6e22e>FallbackDelay</span> <span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Duration</span>
	<span style=color:#a6e22e>KeepAlive</span> <span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Duration</span>
	<span style=color:#a6e22e>Resolver</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>Resolver</span>
	<span style=color:#a6e22e>Cancel</span> <span style=color:#f92672>&lt;-</span><span style=color:#66d9ef>chan</span> <span style=color:#66d9ef>struct</span>{}
	<span style=color:#a6e22e>Control</span> <span style=color:#66d9ef>func</span>(<span style=color:#a6e22e>network</span>, <span style=color:#a6e22e>address</span> <span style=color:#66d9ef>string</span>, <span style=color:#a6e22e>c</span> <span style=color:#a6e22e>syscall</span>.<span style=color:#a6e22e>RawConn</span>) <span style=color:#66d9ef>error</span>
}
</code></pre></div><p>这其中需要我们设置的并不多，主要是Timeout和KeepAlive。Timeout是Dial这个过程的超时时间，而KeepAlive是连接池中连接的超时时间，如下所示：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#a6e22e>trans</span> <span style=color:#f92672>:=</span> <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>Transport</span>{
    <span style=color:#a6e22e>DialContext</span>: (<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>net</span>.<span style=color:#a6e22e>Dialer</span>{
        <span style=color:#a6e22e>Timeout</span>: <span style=color:#ae81ff>30</span> <span style=color:#f92672>*</span> <span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Second</span>,
        <span style=color:#a6e22e>KeepAlive</span>: <span style=color:#ae81ff>30</span> <span style=color:#f92672>*</span> <span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Second</span>,
    }).<span style=color:#a6e22e>DialContext</span>,
}
</code></pre></div><h3 id=设置代理>设置代理</h3>
<p>Transport第一个<code>Proxy</code>字段是用来设置代理，支持HTTP、HTTPS、SOCKS5三种代理方式，首先我们来看看如何设置HTTP和HTTPS代理：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#f92672>package</span> <span style=color:#a6e22e>main</span>

<span style=color:#f92672>import</span> (
	<span style=color:#e6db74>&#34;net/url&#34;</span>
    <span style=color:#e6db74>&#34;net/http&#34;</span>
)

<span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
    <span style=color:#a6e22e>proxyURL</span>, <span style=color:#a6e22e>_</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>url</span>.<span style=color:#a6e22e>Parse</span>(<span style=color:#e6db74>&#34;https://127.0.0.1:1080&#34;</span>)
    <span style=color:#a6e22e>trans</span> <span style=color:#f92672>:=</span> <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>Transport</span>{
        <span style=color:#a6e22e>Proxy</span>: <span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>ProxyURL</span>(<span style=color:#a6e22e>proxyURL</span>),
    }
    <span style=color:#a6e22e>client</span> <span style=color:#f92672>:=</span> <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>Client</span>{
        <span style=color:#a6e22e>Transport</span>: <span style=color:#a6e22e>trans</span>,
    }
    <span style=color:#a6e22e>client</span>.<span style=color:#a6e22e>Get</span>(<span style=color:#e6db74>&#34;https://www.google.com&#34;</span>)
}
</code></pre></div><p>设置SOCKS5代理则需要借助<code>golang.org/x/net/proxy</code>：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#f92672>package</span> <span style=color:#a6e22e>main</span>

<span style=color:#f92672>import</span> (
	<span style=color:#e6db74>&#34;net/url&#34;</span>
	<span style=color:#e6db74>&#34;net/http&#34;</span>
	<span style=color:#e6db74>&#34;golang.org/x/net/proxy&#34;</span>
)

<span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
	<span style=color:#a6e22e>dialer</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>proxy</span>.<span style=color:#a6e22e>SOCKS5</span>(<span style=color:#e6db74>&#34;tcp&#34;</span>, <span style=color:#e6db74>&#34;127.0.0.1:8080&#34;</span>,
        <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>proxy</span>.<span style=color:#a6e22e>Auth</span>{<span style=color:#a6e22e>User</span>:<span style=color:#e6db74>&#34;username&#34;</span>, <span style=color:#a6e22e>Password</span>:<span style=color:#e6db74>&#34;password&#34;</span>},
        <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>net</span>.<span style=color:#a6e22e>Dialer</span> {
            <span style=color:#a6e22e>Timeout</span>: <span style=color:#ae81ff>30</span> <span style=color:#f92672>*</span> <span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Second</span>,
            <span style=color:#a6e22e>KeepAlive</span>: <span style=color:#ae81ff>30</span> <span style=color:#f92672>*</span> <span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Second</span>,
        },
    )
    <span style=color:#a6e22e>trans</span> <span style=color:#f92672>:=</span> <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>Transport</span>{
        <span style=color:#a6e22e>DialContext</span>: <span style=color:#a6e22e>dialer</span>.<span style=color:#a6e22e>DialContext</span>
    }
    <span style=color:#a6e22e>client</span> <span style=color:#f92672>:=</span> <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>Client</span>{
        <span style=color:#a6e22e>Transport</span>: <span style=color:#a6e22e>trans</span>,
    }
    <span style=color:#a6e22e>client</span>.<span style=color:#a6e22e>Get</span>(<span style=color:#e6db74>&#34;https://www.google.com&#34;</span>)
}
</code></pre></div><p>这里的<code>proxy.SOCKS5</code>函数将会返回一个<code>Dialer</code>对象，其传入的参数分别为协议、IP端口、账号密码、<code>Dialer</code>，如果代理不需要账号密码验证的话，第三个字段可以设置为<code>nil</code>。</p>
<h3 id=连接控制>连接控制</h3>
<p>众所周知，HTTP1.0协议使用的是短连接，而HTTP1.1默认使用的是长连接，使用长连接则可以复用连接，减少建立连接的开销。</p>
<p><code>Transport</code>中实现了连接池的功能，可以将连接保存下来以便下次访问此域名，其中也对连接的数量做出了一定的限制。</p>
<p><code>DisableKeepAlives</code>这个字段可以用来关闭长连接，默认值为false，如果有特殊的需求，需要使用短连接，可以设置此字段为true：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#a6e22e>trans</span> <span style=color:#f92672>:=</span> <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>Transport</span>{
    <span style=color:#f92672>...</span>
    <span style=color:#a6e22e>DisableKeepAlives</span>: <span style=color:#66d9ef>true</span>,
}
</code></pre></div><p>除此之外，还可以控制连接的数量和保持时间：</p>
<ol>
<li>
<p><code>MaxConnsPerHost int</code> - 每个域名下最大连接数量，包括正在拨号的、活跃的、空闲的的连接。</p>
<p>值为0表示不限制数量。</p>
</li>
<li>
<p><code>MaxIdleConns int</code> - 空闲连接的最大数量。</p>
<p>DefaultTransport中的默认值为100，在需要发起大量连接时偏小，可以根据需求自行设定。</p>
<p>值为0表示不限制数量。</p>
</li>
<li>
<p><code>MaxIdleConnsPerHost int</code> - 每个域名下空闲连接的最大数量。</p>
<p>值为0则会使用默认的数量，每个域名下只能有两个空闲连接。在对单个网站发起大量连接时，两个连接可能会不够，可以酌情增加此数值。</p>
</li>
<li>
<p><code>IdleConnTimeout time.Duration</code> - 空闲连接的超时时间，从每一次空闲开始算。DefaultTransport中的默认值为90秒。</p>
<p>值为0表示不限制。</p>
</li>
</ol>
<p>由于Transport负担起了连接池的功能，所以在并发使用时，最好将Transport与Client一起复用，不然可能会造成发起过量的长连接，浪费系统资源。</p>
<h2 id=其他>其他</h2>
<h3 id=设置url参数>设置url参数</h3>
<p>在Go的请求方式中，没有给我们提供可以直接设置url参数的方法，所以需要我们自己在url地址中进行拼接。</p>
<p><code>url</code>包中提供了一个<code>url.Values</code>类型，其本质的类型为：<code>map[string][]string</code>，可以让我们拼接参数更加简单，如下所示：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#a6e22e>URL</span> <span style=color:#f92672>:=</span> <span style=color:#e6db74>&#34;http://httpbin.org/get&#34;</span>
<span style=color:#a6e22e>params</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>url</span>.<span style=color:#a6e22e>Values</span>{
    <span style=color:#e6db74>&#34;key1&#34;</span>: {<span style=color:#e6db74>&#34;value&#34;</span>},
    <span style=color:#e6db74>&#34;key2&#34;</span>: {<span style=color:#e6db74>&#34;value2&#34;</span>, <span style=color:#e6db74>&#34;value3&#34;</span>},
}
<span style=color:#a6e22e>URL</span> = <span style=color:#a6e22e>URL</span> <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34;&amp;&#34;</span> <span style=color:#f92672>+</span> <span style=color:#a6e22e>params</span>.<span style=color:#a6e22e>Encode</span>()
<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#a6e22e>URL</span>)
<span style=color:#75715e>// 输出为：http://httpbin.org/get&amp;key1=value&amp;key2=value2&amp;key2=value3
</span></code></pre></div><h2 id=示例>示例</h2>
<p>以下是发起Get请求的一个例子：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#75715e>// 生成client客户端
</span><span style=color:#75715e></span><span style=color:#a6e22e>client</span> <span style=color:#f92672>:=</span> <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>Client</span>{}
<span style=color:#75715e>// 生成Request对象
</span><span style=color:#75715e></span><span style=color:#a6e22e>req</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>NewRequest</span>(<span style=color:#e6db74>&#34;Get&#34;</span>, <span style=color:#e6db74>&#34;http://httpbin.org/get&#34;</span>, <span style=color:#66d9ef>nil</span>)
<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
    <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#a6e22e>err</span>)
}
<span style=color:#75715e>// 添加Header
</span><span style=color:#75715e></span><span style=color:#a6e22e>req</span>.<span style=color:#a6e22e>Header</span>.<span style=color:#a6e22e>Add</span>(<span style=color:#e6db74>&#34;User-Agent&#34;</span>, <span style=color:#e6db74>&#34;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/74.0.3729.108 Safari/537.36&#34;</span>)
<span style=color:#75715e>// 发起请求
</span><span style=color:#75715e></span><span style=color:#a6e22e>resp</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>client</span>.<span style=color:#a6e22e>Do</span>(<span style=color:#a6e22e>req</span>)
<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
    <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#a6e22e>err</span>)
}
<span style=color:#75715e>// 设定关闭响应体
</span><span style=color:#75715e></span><span style=color:#66d9ef>defer</span> <span style=color:#a6e22e>resp</span>.<span style=color:#a6e22e>Body</span>.<span style=color:#a6e22e>Close</span>()
<span style=color:#75715e>// 读取响应体
</span><span style=color:#75715e></span><span style=color:#a6e22e>body</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>ioutil</span>.<span style=color:#a6e22e>ReadAll</span>(<span style=color:#a6e22e>resp</span>.<span style=color:#a6e22e>Body</span>)
<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
    <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#a6e22e>err</span>)
}
<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(string(<span style=color:#a6e22e>body</span>))&lt;<span style=color:#a6e22e>https</span>:<span style=color:#75715e>//colobu.com/2016/07/01/the-complete-guide-to-golang-net-http-timeouts/&gt;)
</span></code></pre></div>
</section>
<footer class=article-footer>
<section class=article-tags>
<a href=/tags/go/>Go</a>
</section>
<section class=article-copyright><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copyright" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><path d="M14.5 9a3.5 4 0 100 6"/></svg>
<span>Licensed under MIT License</span>
</section>
<section class=article-lastmod><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg>
<span>
最后更新于 2021-11-09 23:34:24
</span>
</section></footer>
<link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.13.13/dist/katex.min.css integrity=sha384-RZU/ijkSsFbcmivfdRBQDtwuwVqK7GMOw6IMvKyeWL2K5UAlyp6WonmB8m7Jd0Hn crossorigin=anonymous><script src=https://cdn.jsdelivr.net/npm/katex@0.13.13/dist/katex.min.js integrity=sha384-pK1WpvzWVBQiP0/GjnvRxV4mOb0oxFuyRxJlk6vVw146n3egcN5C925NCP7a7BY8 crossorigin=anonymous defer></script><script src=https://cdn.jsdelivr.net/npm/katex@0.13.13/dist/contrib/auto-render.min.js integrity=sha384-vZTG03m+2yp6N6BNi5iM4rW4oIwk5DfcNdFfxkk9ZWpDriOkXX8voJBFrAO7MpVl crossorigin=anonymous defer></script><script>window.addEventListener("DOMContentLoaded",()=>{renderMathInElement(document.querySelector(`.article-content`),{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1},{left:"\\(",right:"\\)",display:!1},{left:"\\[",right:"\\]",display:!0}]})})</script>
</article>
<aside class=related-contents--wrapper>
<h2 class=section-title>相关文章</h2>
<div class=related-contents>
<div class="flex article-list--tile">
<article>
<a href=/post/go-%E4%BB%A4%E7%89%8C%E6%A1%B6%E9%99%90%E6%B5%81%E5%99%A8-golang.org/x/time/rate/>
<div class=article-details>
<h2 class=article-title>Go 令牌桶限流器 golang.org/x/time/rate</h2>
</div>
</a>
</article>
<article>
<a href=/post/go-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%A4%84%E7%90%86-strings/>
<div class=article-details>
<h2 class=article-title>Go 字符串处理 strings</h2>
</div>
</a>
</article>
<article>
<a href=/post/go-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2-strconv/>
<div class=article-details>
<h2 class=article-title>Go 字符串类型转换 strconv</h2>
</div>
</a>
</article>
<article>
<a href=/post/go-%E6%A0%87%E5%87%86%E5%BA%93-io/>
<div class=article-details>
<h2 class=article-title>Go 标准库 io</h2>
</div>
</a>
</article>
<article>
<a href=/post/go-%E6%A0%87%E5%87%86%E5%BA%93-ioutil/>
<div class=article-details>
<h2 class=article-title>Go 标准库 ioutil</h2>
</div>
</a>
</article>
</div>
</div>
</aside>
<footer class=site-footer>
<section class=copyright>
&copy;
2021 WNANBEI
</section>
<section class=powerby>
The world has kissed my soul with its pain, asking for its return in songs. <br>
Built with <a href=https://gohugo.io/ target=_blank rel=noopener>Hugo</a> <br>
Theme <b><a href=https://github.com/CaiJimmy/hugo-theme-stack target=_blank rel=noopener data-version=3.5.0>Stack</a></b> designed by <a href=https://jimmycai.com target=_blank rel=noopener>Jimmy</a>
</section>
</footer>
<div class=pswp tabindex=-1 role=dialog aria-hidden=true>
<div class=pswp__bg></div>
<div class=pswp__scroll-wrap>
<div class=pswp__container>
<div class=pswp__item></div>
<div class=pswp__item></div>
<div class=pswp__item></div>
</div>
<div class="pswp__ui pswp__ui--hidden">
<div class=pswp__top-bar>
<div class=pswp__counter></div>
<button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
<button class="pswp__button pswp__button--share" title=Share></button>
<button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
<button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>
<div class=pswp__preloader>
<div class=pswp__preloader__icn>
<div class=pswp__preloader__cut>
<div class=pswp__preloader__donut></div>
</div>
</div>
</div>
</div>
<div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
<div class=pswp__share-tooltip></div>
</div>
<button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
</button>
<button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
</button>
<div class=pswp__caption>
<div class=pswp__caption__center></div>
</div>
</div>
</div>
</div><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo=" crossorigin=anonymous defer></script><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU=" crossorigin=anonymous defer></script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.css integrity="sha256-c0uckgykQ9v5k+IqViZOZKc47Jn7KQil4/MP3ySA3F8=" crossorigin=anonymous><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.css integrity="sha256-SBLU4vv6CA6lHsZ1XyTdhyjJxCjPif/TRkjnsyGAGnE=" crossorigin=anonymous>
</main>
<aside class="sidebar right-sidebar sticky">
<section class="widget archives">
<div class=widget-icon><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-hash" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><line x1="5" y1="9" x2="19" y2="9"/><line x1="5" y1="15" x2="19" y2="15"/><line x1="11" y1="4" x2="7" y2="20"/><line x1="17" y1="4" x2="13" y2="20"/></svg>
</div>
<h2 class="widget-title section-title">目录</h2>
<div class=widget--toc>
<nav id=TableOfContents>
<ol>
<li><a href=#简单请求>简单请求</a></li>
<li><a href=#client>Client</a>
<ol>
<li><a href=#设置超时>设置超时</a></li>
<li><a href=#控制重定向>控制重定向</a></li>
<li><a href=#cookiejar管理>CookieJar管理</a></li>
</ol>
</li>
<li><a href=#request>Request</a>
<ol>
<li><a href=#method>Method</a></li>
<li><a href=#url>URL</a></li>
<li><a href=#proto>Proto</a></li>
<li><a href=#发起post请求>发起Post请求</a></li>
<li><a href=#设置header>设置Header</a></li>
<li><a href=#添加cookie>添加Cookie</a></li>
</ol>
</li>
<li><a href=#transport>Transport</a>
<ol>
<li><a href=#拨号>拨号</a></li>
<li><a href=#设置代理>设置代理</a></li>
<li><a href=#连接控制>连接控制</a></li>
</ol>
</li>
<li><a href=#其他>其他</a>
<ol>
<li><a href=#设置url参数>设置url参数</a></li>
</ol>
</li>
<li><a href=#示例>示例</a></li>
</ol>
</nav>
</div>
</section>
</aside>
</div>
<script src=https://cdn.jsdelivr.net/npm/node-vibrant@3.1.5/dist/vibrant.min.js integrity="sha256-5NovOZc4iwiAWTYIFiIM7DxKUXKWvpVEuMEPLzcm5/g=" crossorigin=anonymous defer></script><script type=text/javascript src=/ts/main.js defer></script>
<script>(function(){const a=document.createElement('link');a.href="https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap",a.type="text/css",a.rel="stylesheet",document.head.appendChild(a)})()</script>
</body>
</html>