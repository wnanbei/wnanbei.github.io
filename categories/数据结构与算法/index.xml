<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>数据结构与算法 on WNANBEI</title><link>https://wnanbei.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/</link><description>Recent content in 数据结构与算法 on WNANBEI</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><atom:link href="https://wnanbei.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/index.xml" rel="self" type="application/rss+xml"/><item><title>动态规划之子序列问题</title><link>https://wnanbei.github.io/post/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E4%B9%8B%E5%AD%90%E5%BA%8F%E5%88%97%E9%97%AE%E9%A2%98/</link><pubDate>Sat, 10 Oct 2020 00:00:00 +0000</pubDate><guid>https://wnanbei.github.io/post/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E4%B9%8B%E5%AD%90%E5%BA%8F%E5%88%97%E9%97%AE%E9%A2%98/</guid><description>&lt;p>&lt;strong>子序列&lt;/strong>是指给定一个序列，将给定序列中零个或多个元素去掉之后得到的结果，子序列可以是不连续的。&lt;/p>
&lt;p>一般来说，这类问题都是求一个最长子序列。而一旦涉及到子序列和最值，那几乎可以肯定，考察的是动态规划技巧，时间复杂度一般都是 $O(n^2)$。&lt;/p></description></item><item><title>动态规划之背包问题</title><link>https://wnanbei.github.io/post/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E4%B9%8B%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/</link><pubDate>Sat, 10 Oct 2020 00:00:00 +0000</pubDate><guid>https://wnanbei.github.io/post/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E4%B9%8B%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/</guid><description>&lt;p>背包问题（Knapsack problem）是一种组合优化的NP完全问题。&lt;/p>
&lt;p>问题可以描述为：给定一组物品，每种物品都有自己的重量和价格，在限定的总重量内，我们如何选择，才能使得物品的总价格最高。&lt;/p>
&lt;p>问题的名称来源于如何选择最合适的物品放置于给定背包中。&lt;/p></description></item><item><title>动态规划之贪心算法</title><link>https://wnanbei.github.io/post/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E4%B9%8B%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/</link><pubDate>Sat, 10 Oct 2020 00:00:00 +0000</pubDate><guid>https://wnanbei.github.io/post/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E4%B9%8B%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/</guid><description>&lt;p>贪心算法可以认为是动态规划算法的一个特例，相比动态规划：&lt;/p>
&lt;ul>
&lt;li>使用贪心算法需要满足更多的条件（贪心选择性质）。&lt;/li>
&lt;li>效率比动态规划高。&lt;/li>
&lt;/ul>
&lt;p>一个算法问题使用暴力解法需要指数级时间，如果能使用动态规划消除重叠子问题，就可以降到多项式级别的时间，如果满足贪心选择性质，那么可以进一步降低时间复杂度，达到线性级别。&lt;/p></description></item><item><title>数据结构与算法之二叉搜索树</title><link>https://wnanbei.github.io/post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</link><pubDate>Sat, 10 Oct 2020 00:00:00 +0000</pubDate><guid>https://wnanbei.github.io/post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</guid><description>&lt;p>二叉搜索树 &lt;code>Binary Search Tree&lt;/code> 简称 &lt;code>BST&lt;/code>，是二叉树的一种特殊形式。二叉搜索树每个节点 &lt;code>node&lt;/code> 都具有以下性质：&lt;/p>
&lt;ul>
&lt;li>左子树所有子节点的值都比 &lt;code>node&lt;/code> 的值要小，右子树所有子节点的值都比 &lt;code>node&lt;/code> 的值大。&lt;/li>
&lt;li>它的左侧子树和右侧子树都是 BST。&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>BST 有一个重要的性质: BST 的中序遍历结果是有序的（升序）&lt;/strong>。&lt;/p></description></item><item><title>数据结构与算法之二叉树</title><link>https://wnanbei.github.io/post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E4%BA%8C%E5%8F%89%E6%A0%91/</link><pubDate>Sat, 10 Oct 2020 00:00:00 +0000</pubDate><guid>https://wnanbei.github.io/post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E4%BA%8C%E5%8F%89%E6%A0%91/</guid><description>&lt;p>树是一种经常用到的数据结构，用来模拟具有树状结构性质的数据集合。树里的每一个节点有一个值和一个包含所有子节点的列表。&lt;/p>
&lt;p>从图的观点来看，树也可视为一个拥有 N 个节点和 N-1 条边的一个有向无环图。&lt;/p>
&lt;p>二叉树是一种典型的树状结构，是每个节点最多有两个子树的树结构，通常子树被称作左子树和右子树。&lt;/p></description></item><item><title>数据结构与算法之单链表问题</title><link>https://wnanbei.github.io/post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E5%8D%95%E9%93%BE%E8%A1%A8%E9%97%AE%E9%A2%98/</link><pubDate>Sat, 10 Oct 2020 00:00:00 +0000</pubDate><guid>https://wnanbei.github.io/post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E5%8D%95%E9%93%BE%E8%A1%A8%E9%97%AE%E9%A2%98/</guid><description/></item><item><title>数据结构与算法之常见动态规划问题</title><link>https://wnanbei.github.io/post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E5%B8%B8%E8%A7%81%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E9%97%AE%E9%A2%98/</link><pubDate>Sat, 10 Oct 2020 00:00:00 +0000</pubDate><guid>https://wnanbei.github.io/post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E5%B8%B8%E8%A7%81%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E9%97%AE%E9%A2%98/</guid><description>&lt;p>&lt;strong>动态规划问题的一般形式就是求最值&lt;/strong>。比如求&lt;strong>最长&lt;/strong>递增子序列，&lt;strong>最小&lt;/strong>编辑距离等等。&lt;/p>
&lt;p>&lt;strong>求解动态规划的核心问题是穷举&lt;/strong>。因为要求最值，要把所有可行的答案穷举出来，然后在其中找最值。&lt;/p></description></item><item><title>数据结构与算法之数组</title><link>https://wnanbei.github.io/post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E6%95%B0%E7%BB%84/</link><pubDate>Sat, 10 Oct 2020 00:00:00 +0000</pubDate><guid>https://wnanbei.github.io/post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E6%95%B0%E7%BB%84/</guid><description/></item></channel></rss>