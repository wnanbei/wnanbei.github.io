<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Posts on WNANBEI</title><link>https://wnanbei.github.io/post/</link><description>Recent content in Posts on WNANBEI</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Fri, 12 Nov 2021 00:00:00 +0000</lastBuildDate><atom:link href="https://wnanbei.github.io/post/index.xml" rel="self" type="application/rss+xml"/><item><title>防御性编程</title><link>https://wnanbei.github.io/post/%E9%98%B2%E5%BE%A1%E6%80%A7%E7%BC%96%E7%A8%8B/</link><pubDate>Fri, 12 Nov 2021 00:00:00 +0000</pubDate><guid>https://wnanbei.github.io/post/%E9%98%B2%E5%BE%A1%E6%80%A7%E7%BC%96%E7%A8%8B/</guid><description>&lt;p>&lt;strong>防御性编程&lt;/strong>（Defensive programming）是&lt;strong>防御&lt;/strong>式设计的一种具体体现，它是为了保证，对程序的不可预见的使用，不会造成程序功能上的损坏。&lt;/p>
&lt;p>它可以被看作是为了减少或消除墨菲定律效力的方法。&lt;/p></description></item><item><title>MongoDB 索引用法与原理</title><link>https://wnanbei.github.io/post/mongodb-%E7%B4%A2%E5%BC%95%E7%94%A8%E6%B3%95%E4%B8%8E%E5%8E%9F%E7%90%86/</link><pubDate>Wed, 10 Nov 2021 00:00:00 +0000</pubDate><guid>https://wnanbei.github.io/post/mongodb-%E7%B4%A2%E5%BC%95%E7%94%A8%E6%B3%95%E4%B8%8E%E5%8E%9F%E7%90%86/</guid><description/></item><item><title>模板模式 - 设计模式系列（一）</title><link>https://wnanbei.github.io/post/%E6%A8%A1%E6%9D%BF%E6%A8%A1%E5%BC%8F-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%B3%BB%E5%88%97%E4%B8%80/</link><pubDate>Tue, 09 Nov 2021 00:00:00 +0000</pubDate><guid>https://wnanbei.github.io/post/%E6%A8%A1%E6%9D%BF%E6%A8%A1%E5%BC%8F-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%B3%BB%E5%88%97%E4%B8%80/</guid><description>&lt;p>模板模式是指抽象类里定义好&lt;strong>算法的执行步骤&lt;/strong>和&lt;strong>具体算法&lt;/strong>，以及可能发生变化的算法定义为&lt;strong>抽象方法&lt;/strong>。不同的子类继承该抽象类，并实现父类的抽象方法。&lt;/p>
&lt;p>优势：&lt;/p>
&lt;ul>
&lt;li>不变的算法被继承复用：不变的部分高度封装、复用。&lt;/li>
&lt;li>变化的算法子类继承并具体实现：变化的部分子类只需要具体实现抽象的部分即可，方便扩展，且可无限扩展。&lt;/li>
&lt;/ul></description></item><item><title>ElasticSearch CRUD 接口</title><link>https://wnanbei.github.io/post/elasticsearch-crud-%E6%8E%A5%E5%8F%A3/</link><pubDate>Sat, 06 Nov 2021 16:17:25 +0000</pubDate><guid>https://wnanbei.github.io/post/elasticsearch-crud-%E6%8E%A5%E5%8F%A3/</guid><description>&lt;p>ElasticSearch 使用 HTTP 协议的 Restful 接口，来对接不同的程序系统。&lt;/p></description></item><item><title>MongoDB CRUD 操作</title><link>https://wnanbei.github.io/post/mongodb-crud-%E6%93%8D%E4%BD%9C/</link><pubDate>Fri, 05 Nov 2021 00:00:00 +0000</pubDate><guid>https://wnanbei.github.io/post/mongodb-crud-%E6%93%8D%E4%BD%9C/</guid><description/></item><item><title>Go 代码检查工具 golangci-lint</title><link>https://wnanbei.github.io/post/go-%E4%BB%A3%E7%A0%81%E6%A3%80%E6%9F%A5%E5%B7%A5%E5%85%B7-golangci-lint/</link><pubDate>Mon, 01 Nov 2021 00:00:00 +0000</pubDate><guid>https://wnanbei.github.io/post/go-%E4%BB%A3%E7%A0%81%E6%A3%80%E6%9F%A5%E5%B7%A5%E5%85%B7-golangci-lint/</guid><description>&lt;p>&lt;code>golangci-lint&lt;/code> 是一个代码检查工具的集合，聚集了多种 Go 代码检查工具，如 &lt;code>golint&lt;/code>、&lt;code>go vet&lt;/code> 等。&lt;/p>
&lt;p>优点：&lt;/p>
&lt;ul>
&lt;li>运行速度快&lt;/li>
&lt;li>可以集成到 vscode、goland 等开发工具中&lt;/li>
&lt;li>包含了非常多种代码检查器&lt;/li>
&lt;li>可以集成到 CI 中&lt;/li>
&lt;/ul>
&lt;p>这是包含的代码检查器列表：&lt;a class="link" href="https://golangci-lint.run/usage/linters/" target="_blank" rel="noopener"
>Linters&lt;/a>&lt;/p></description></item><item><title>Go 令牌桶限流器 golang.org/x/time/rate</title><link>https://wnanbei.github.io/post/go-%E4%BB%A4%E7%89%8C%E6%A1%B6%E9%99%90%E6%B5%81%E5%99%A8-golang.org/x/time/rate/</link><pubDate>Mon, 25 Oct 2021 00:00:00 +0000</pubDate><guid>https://wnanbei.github.io/post/go-%E4%BB%A4%E7%89%8C%E6%A1%B6%E9%99%90%E6%B5%81%E5%99%A8-golang.org/x/time/rate/</guid><description>&lt;p>&lt;code>golang.org/x/time/rate&lt;/code> 提供了一个使用令牌桶 &lt;code>Token Bucket&lt;/code> 算法实现的限流器。&lt;/p></description></item><item><title>CSP 并发编程模型</title><link>https://wnanbei.github.io/post/csp-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E6%A8%A1%E5%9E%8B/</link><pubDate>Thu, 05 Aug 2021 00:00:00 +0000</pubDate><guid>https://wnanbei.github.io/post/csp-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E6%A8%A1%E5%9E%8B/</guid><description>&lt;p>&lt;code>CSP - Communicating Sequential Process&lt;/code>，通信顺序进程，是一种并发编程模型，用于描述两个独立的并发实体通过共享的通讯 channel 进行通信。&lt;/p></description></item><item><title>Go GC 垃圾回收</title><link>https://wnanbei.github.io/post/go-gc-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/</link><pubDate>Thu, 05 Aug 2021 00:00:00 +0000</pubDate><guid>https://wnanbei.github.io/post/go-gc-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/</guid><description>&lt;p>垃圾回收 - &lt;code>GC&lt;/code> - &lt;code>garbage collection&lt;/code> 是自动内存管理的一种形式。通常由垃圾收集器收集并适时回收或重用不再被对象占用的内存。&lt;/p>
&lt;p>垃圾回收作为内存管理的一部分，包含 3 个重要的功能：&lt;/p>
&lt;ul>
&lt;li>如何分配和管理新对象。&lt;/li>
&lt;li>如何识别正在使用中的对象。&lt;/li>
&lt;li>如何清除不再使用的对象。&lt;/li>
&lt;/ul></description></item><item><title>Go Gorm CRUD</title><link>https://wnanbei.github.io/post/go-gorm-crud/</link><pubDate>Thu, 05 Aug 2021 00:00:00 +0000</pubDate><guid>https://wnanbei.github.io/post/go-gorm-crud/</guid><description>&lt;p>Gorm 常见 CRUD 操作 API。&lt;/p></description></item><item><title>Go Gorm 数据库连接与模型</title><link>https://wnanbei.github.io/post/go-gorm-%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E4%B8%8E%E6%A8%A1%E5%9E%8B/</link><pubDate>Thu, 05 Aug 2021 00:00:00 +0000</pubDate><guid>https://wnanbei.github.io/post/go-gorm-%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E4%B8%8E%E6%A8%A1%E5%9E%8B/</guid><description>&lt;p>对开发者友好的 Go ORM 库，v2 版本。&lt;/p></description></item><item><title>Go 字符串处理 strings</title><link>https://wnanbei.github.io/post/go-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%A4%84%E7%90%86-strings/</link><pubDate>Thu, 05 Aug 2021 00:00:00 +0000</pubDate><guid>https://wnanbei.github.io/post/go-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%A4%84%E7%90%86-strings/</guid><description>&lt;p>作为一种基本数据结构，每种语言都有一些对于字符串的预定义处理函数。Go 中使用 &lt;code>strings&lt;/code> 包来完成对字符串的主要操作。&lt;/p></description></item><item><title>Go 字符串类型转换 strconv</title><link>https://wnanbei.github.io/post/go-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2-strconv/</link><pubDate>Thu, 05 Aug 2021 00:00:00 +0000</pubDate><guid>https://wnanbei.github.io/post/go-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2-strconv/</guid><description>&lt;p>Strconv 包含了一些变量用于获取程序运行的操作系统平台下 int 类型所占的位数，如：&lt;code>strconv.IntSize&lt;/code>。&lt;/p>
&lt;p>任何类型 &lt;strong>T&lt;/strong> 转换为字符串总是成功的。&lt;/p></description></item><item><title>Go 标准库 io</title><link>https://wnanbei.github.io/post/go-%E6%A0%87%E5%87%86%E5%BA%93-io/</link><pubDate>Thu, 05 Aug 2021 00:00:00 +0000</pubDate><guid>https://wnanbei.github.io/post/go-%E6%A0%87%E5%87%86%E5%BA%93-io/</guid><description/></item><item><title>Go 标准库 ioutil</title><link>https://wnanbei.github.io/post/go-%E6%A0%87%E5%87%86%E5%BA%93-ioutil/</link><pubDate>Thu, 05 Aug 2021 00:00:00 +0000</pubDate><guid>https://wnanbei.github.io/post/go-%E6%A0%87%E5%87%86%E5%BA%93-ioutil/</guid><description/></item><item><title>Go 第三方库 gjson</title><link>https://wnanbei.github.io/post/go-%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93-gjson/</link><pubDate>Thu, 05 Aug 2021 00:00:00 +0000</pubDate><guid>https://wnanbei.github.io/post/go-%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93-gjson/</guid><description>&lt;p>这是一个主要功能为从 Json 中提取值的包。&lt;/p></description></item><item><title>Go 第三方库 grpc</title><link>https://wnanbei.github.io/post/go-%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93-grpc/</link><pubDate>Thu, 05 Aug 2021 00:00:00 +0000</pubDate><guid>https://wnanbei.github.io/post/go-%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93-grpc/</guid><description>&lt;p>&lt;code>gRPC&lt;/code> 是一个高性能、通用的开源 RPC 框架，由 Google 主要面向移动应用开发并基于 &lt;code>HTTP/2&lt;/code> 协议标准而设计，基于 &lt;code>ProtoBuf(Protocol Buffers)&lt;/code> 序列化协议开发，且支持众多开发语言。&lt;/p>
&lt;p>使用 gRPC， 可以在一个 &lt;code>.proto&lt;/code> 文件中定义服务，并使用任何支持它的语言去实现客户端和服务端。使用 gRPC定义一个服务，指定一个可以远程调用的带有参数和返回类型的的方法，客户端可以像调用本地方法一样直接调用服务端的方法。gRPC 解决了不同语言及环境间通信的复杂性。&lt;/p>
&lt;p>使用 &lt;code>protocol buffers&lt;/code> 还能获得其他好处：&lt;/p>
&lt;ul>
&lt;li>包括高效的序列号&lt;/li>
&lt;li>简单的 IDL&lt;/li>
&lt;li>容易进行接口更新。&lt;/li>
&lt;/ul>
&lt;p>使用 gRPC 能更容易编写跨语言的分布式代码。&lt;/p></description></item><item><title>Go 第三方库 viper</title><link>https://wnanbei.github.io/post/go-%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93-viper/</link><pubDate>Thu, 05 Aug 2021 00:00:00 +0000</pubDate><guid>https://wnanbei.github.io/post/go-%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93-viper/</guid><description>&lt;p>此包用于读取各类配置文件。&lt;/p>
&lt;p>安装：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">go get github.com/spf13/viper
&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>Viper&lt;/code> 支持的配置文件后缀名如下：&lt;/p>
&lt;p>&lt;code>json&lt;/code>, &lt;code>toml&lt;/code>, &lt;code>yaml&lt;/code>, &lt;code>yml&lt;/code>, &lt;code>properties&lt;/code>, &lt;code>props&lt;/code>, &lt;code>prop&lt;/code>, &lt;code>hcl&lt;/code>, &lt;code>dotenv&lt;/code>, &lt;code>env&lt;/code>, &lt;code>ini&lt;/code>&lt;/p></description></item><item><title>Go 第三方库 zap</title><link>https://wnanbei.github.io/post/go-%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93-zap/</link><pubDate>Thu, 05 Aug 2021 00:00:00 +0000</pubDate><guid>https://wnanbei.github.io/post/go-%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93-zap/</guid><description>&lt;p>此包用于结构化记录日志。&lt;/p>
&lt;p>安装：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">go get -u go.uber.org/zap
&lt;/code>&lt;/pre>&lt;/div>&lt;p>导入：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-go" data-lang="go">&lt;span style="color:#f92672">import&lt;/span> &lt;span style="color:#e6db74">&amp;#34;go.uber.org/zap&amp;#34;&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>优点：&lt;/p>
&lt;ul>
&lt;li>性能高，与 Zerolog 同一水平。&lt;/li>
&lt;/ul></description></item><item><title>Go GMP 调度器</title><link>https://wnanbei.github.io/post/go-gmp-%E8%B0%83%E5%BA%A6%E5%99%A8/</link><pubDate>Sun, 01 Aug 2021 00:00:00 +0000</pubDate><guid>https://wnanbei.github.io/post/go-gmp-%E8%B0%83%E5%BA%A6%E5%99%A8/</guid><description>&lt;p>GMP Scheduler 是 Runtime 中几乎最重要的组件，它的作用是：&lt;/p>
&lt;blockquote>
&lt;p>For scheduling goroutines onto kernel threads.&lt;/p>
&lt;/blockquote>
&lt;p>GMP Scheduler 的核心思想是：&lt;/p>
&lt;ol>
&lt;li>重用线程。&lt;/li>
&lt;li>限制同时运行（不包含阻塞）的线程数为 N，N 为 CPU 逻辑核心数。&lt;/li>
&lt;/ol>
&lt;p>Go scheduler 的职责就是将所有处于 runnable 的 Goroutines 均匀分布到在 P 上运行的 M，利用多核并行，实现更强大的并发。&lt;/p></description></item><item><title>Redis 底层数据结构</title><link>https://wnanbei.github.io/post/redis-%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</link><pubDate>Mon, 07 Jun 2021 00:00:00 +0000</pubDate><guid>https://wnanbei.github.io/post/redis-%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</guid><description>&lt;p>Redis 底层所采用的数据结构，分别有：SDS String、HashTable、ZipList、QuickList、IntSet、SkipList。&lt;/p></description></item><item><title>Redis 缓存与淘汰策略</title><link>https://wnanbei.github.io/post/redis-%E7%BC%93%E5%AD%98%E4%B8%8E%E6%B7%98%E6%B1%B0%E7%AD%96%E7%95%A5/</link><pubDate>Mon, 07 Jun 2021 00:00:00 +0000</pubDate><guid>https://wnanbei.github.io/post/redis-%E7%BC%93%E5%AD%98%E4%B8%8E%E6%B7%98%E6%B1%B0%E7%AD%96%E7%95%A5/</guid><description>&lt;p>常见的缓存类型以及现实中常遇到的缓存问题，Redis 所采用的过期淘汰策略 LRU、LFU 等。&lt;/p></description></item><item><title>Redis 使用规范</title><link>https://wnanbei.github.io/post/redis-%E4%BD%BF%E7%94%A8%E8%A7%84%E8%8C%83/</link><pubDate>Sun, 06 Jun 2021 00:00:00 +0000</pubDate><guid>https://wnanbei.github.io/post/redis-%E4%BD%BF%E7%94%A8%E8%A7%84%E8%8C%83/</guid><description>&lt;p>Redis 使用过程中的一些规范，包括 key 的名称、禁用的命令等。&lt;/p></description></item><item><title>Redis 安装配置</title><link>https://wnanbei.github.io/post/redis-%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/</link><pubDate>Sun, 06 Jun 2021 00:00:00 +0000</pubDate><guid>https://wnanbei.github.io/post/redis-%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/</guid><description>&lt;p>Redis 在 centos 系统下的安装配置流程。&lt;/p></description></item><item><title>Redis 数据持久化策略</title><link>https://wnanbei.github.io/post/redis-%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96%E7%AD%96%E7%95%A5/</link><pubDate>Sun, 06 Jun 2021 00:00:00 +0000</pubDate><guid>https://wnanbei.github.io/post/redis-%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96%E7%AD%96%E7%95%A5/</guid><description>&lt;p>redis 提供了两种持久化的方式，分别是 &lt;code>RDB(Redis DataBase)&lt;/code> 和 &lt;code>AOF(Append Only File)&lt;/code>。&lt;/p></description></item><item><title>Redis 数据类型</title><link>https://wnanbei.github.io/post/redis-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</link><pubDate>Sun, 06 Jun 2021 00:00:00 +0000</pubDate><guid>https://wnanbei.github.io/post/redis-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</guid><description>&lt;p>在 Redis 中，常用的 5 种数据类型和应用场景如下：&lt;/p>
&lt;ul>
&lt;li>&lt;code>String&lt;/code>：缓存、计数器、限速器、分布式锁等。&lt;/li>
&lt;li>&lt;code>List&lt;/code>：链表、队列、微博关注人时间轴列表等。&lt;/li>
&lt;li>&lt;code>Hash&lt;/code>： 用户信息、Hash 表等。&lt;/li>
&lt;li>&lt;code>Set&lt;/code>： 去重、赞、踩、共同好友等。&lt;/li>
&lt;li>&lt;code>Sorted Set&lt;/code>：访问量排行榜、点击量排行榜等。&lt;/li>
&lt;/ul></description></item><item><title>Redis 整体架构</title><link>https://wnanbei.github.io/post/redis-%E6%95%B4%E4%BD%93%E6%9E%B6%E6%9E%84/</link><pubDate>Sun, 06 Jun 2021 00:00:00 +0000</pubDate><guid>https://wnanbei.github.io/post/redis-%E6%95%B4%E4%BD%93%E6%9E%B6%E6%9E%84/</guid><description>&lt;p>Redis 的性能、整体架构设计、单线程原因等。&lt;/p></description></item><item><title>Go 互斥锁 sync.Mutex</title><link>https://wnanbei.github.io/post/go-%E4%BA%92%E6%96%A5%E9%94%81-sync.mutex/</link><pubDate>Wed, 05 May 2021 00:00:00 +0000</pubDate><guid>https://wnanbei.github.io/post/go-%E4%BA%92%E6%96%A5%E9%94%81-sync.mutex/</guid><description>&lt;p>&lt;code>sync.Mutex&lt;/code> 是一个互斥锁，默认为零值时为开锁状态。&lt;/p></description></item><item><title>Go 原子操作 atomic</title><link>https://wnanbei.github.io/post/go-%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C-atomic/</link><pubDate>Wed, 05 May 2021 00:00:00 +0000</pubDate><guid>https://wnanbei.github.io/post/go-%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C-atomic/</guid><description>&lt;p>&lt;code>atomic&lt;/code> 包封装了系统底层的原子操作。官方建议尽量少使用此包的原子操作，尽量遵循通过通信分享内存，而不是通过分享内存来通信的原则。&lt;/p>
&lt;p>这个包的方法有以下特点：&lt;/p>
&lt;ul>
&lt;li>方法操作的都是 &lt;code>int&lt;/code> 系列类型或指针。&lt;/li>
&lt;li>操作的数据需要其地址。&lt;/li>
&lt;/ul></description></item><item><title>Go 对象池 sync.Pool</title><link>https://wnanbei.github.io/post/go-%E5%AF%B9%E8%B1%A1%E6%B1%A0-sync.pool/</link><pubDate>Wed, 05 May 2021 00:00:00 +0000</pubDate><guid>https://wnanbei.github.io/post/go-%E5%AF%B9%E8%B1%A1%E6%B1%A0-sync.pool/</guid><description>&lt;p>sync.Pool 是一个协程安全的内存池。主要用于增加临时对象的内存复用率，减少内存分配和 GC STW 的开销。、&lt;/p></description></item><item><title>Go 并发安全的 sync.Map</title><link>https://wnanbei.github.io/post/go-%E5%B9%B6%E5%8F%91%E5%AE%89%E5%85%A8%E7%9A%84-sync.map/</link><pubDate>Wed, 05 May 2021 00:00:00 +0000</pubDate><guid>https://wnanbei.github.io/post/go-%E5%B9%B6%E5%8F%91%E5%AE%89%E5%85%A8%E7%9A%84-sync.map/</guid><description>&lt;p>&lt;code>sync.Map&lt;/code> 是标准库 &lt;code>sync&lt;/code> 中实现的并发安全的 map。&lt;/p></description></item><item><title>Go 标准库 sync.WaitGroup</title><link>https://wnanbei.github.io/post/go-%E6%A0%87%E5%87%86%E5%BA%93-sync.waitgroup/</link><pubDate>Wed, 05 May 2021 00:00:00 +0000</pubDate><guid>https://wnanbei.github.io/post/go-%E6%A0%87%E5%87%86%E5%BA%93-sync.waitgroup/</guid><description/></item><item><title>Go 读写锁 sync.RWMutex</title><link>https://wnanbei.github.io/post/go-%E8%AF%BB%E5%86%99%E9%94%81-sync.rwmutex/</link><pubDate>Wed, 05 May 2021 00:00:00 +0000</pubDate><guid>https://wnanbei.github.io/post/go-%E8%AF%BB%E5%86%99%E9%94%81-sync.rwmutex/</guid><description>&lt;p>&lt;code>sync.RWMutex&lt;/code> 是一个读写锁，在读多写少的场景中，比 Mutex 的并发能力有很大的提升。&lt;/p></description></item><item><title>MySQL Join 连接详解</title><link>https://wnanbei.github.io/post/mysql-join-%E8%BF%9E%E6%8E%A5%E8%AF%A6%E8%A7%A3/</link><pubDate>Sat, 06 Feb 2021 00:00:00 +0000</pubDate><guid>https://wnanbei.github.io/post/mysql-join-%E8%BF%9E%E6%8E%A5%E8%AF%A6%E8%A7%A3/</guid><description>&lt;p>在 MySQL 中，不同的 Join 语句会使用不同的算法扫描数据。&lt;/p>
&lt;p>直接使用 Join 时，MySQL 的优化器会自动选定 Join 的驱动表，如果使用 &lt;code>straight_join&lt;/code> 可以指定前表为驱动表。&lt;/p></description></item><item><title>MySQL 中的锁</title><link>https://wnanbei.github.io/post/mysql-%E4%B8%AD%E7%9A%84%E9%94%81/</link><pubDate>Sat, 06 Feb 2021 00:00:00 +0000</pubDate><guid>https://wnanbei.github.io/post/mysql-%E4%B8%AD%E7%9A%84%E9%94%81/</guid><description>&lt;p>根据加锁的范围，MySQL 的锁大致可以分成三类：&lt;/p>
&lt;ol>
&lt;li>全局锁&lt;/li>
&lt;li>表锁&lt;/li>
&lt;li>行锁&lt;/li>
&lt;/ol></description></item><item><title>MySQL 事务与隔离级别</title><link>https://wnanbei.github.io/post/mysql-%E4%BA%8B%E5%8A%A1%E4%B8%8E%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/</link><pubDate>Sat, 06 Feb 2021 00:00:00 +0000</pubDate><guid>https://wnanbei.github.io/post/mysql-%E4%BA%8B%E5%8A%A1%E4%B8%8E%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/</guid><description>&lt;p>事务是保证一组数据库操作，要么全部成功，要么全部失败。&lt;/p>
&lt;p>在 MySQL 中，事务支持在引擎层实现。MySQL 并不是所有的引擎都支持事务。比如 MySQL 原生的 MyISAM 引擎不支持事务，这也是 MyISAM 被 InnoDB 取代的重要原因之一。&lt;/p>
&lt;p>ACID（&lt;code>Atomicity&lt;/code>、&lt;code>Consistency&lt;/code>、&lt;code>Isolation&lt;/code>、&lt;code>Durability&lt;/code>，即原子性、一致性、隔离性、持久性）。&lt;/p></description></item><item><title>MySQL 安装与配置</title><link>https://wnanbei.github.io/post/mysql-%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE/</link><pubDate>Sat, 06 Feb 2021 00:00:00 +0000</pubDate><guid>https://wnanbei.github.io/post/mysql-%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE/</guid><description>&lt;p>&lt;code>MySQL&lt;/code> 在今年初发布了正式的 8.0 版本，据说性能相比 5.7 提升了两倍。今天我们就来安装和配置一下&lt;code>MySQL8.0&lt;/code>。&lt;/p>
&lt;p>安装环境为 &lt;code>Centos7&lt;/code>。&lt;/p>
&lt;p>MySQL 的安装主要有两种方式，一种是使用 &lt;code>yum&lt;/code> 命令在线安装，一种是下载源代码，离线安装。&lt;/p></description></item><item><title>MySQL 建表与修改</title><link>https://wnanbei.github.io/post/mysql-%E5%BB%BA%E8%A1%A8%E4%B8%8E%E4%BF%AE%E6%94%B9/</link><pubDate>Sat, 06 Feb 2021 00:00:00 +0000</pubDate><guid>https://wnanbei.github.io/post/mysql-%E5%BB%BA%E8%A1%A8%E4%B8%8E%E4%BF%AE%E6%94%B9/</guid><description/></item><item><title>MySQL 数据库设计规范</title><link>https://wnanbei.github.io/post/mysql-%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1%E8%A7%84%E8%8C%83/</link><pubDate>Sat, 06 Feb 2021 00:00:00 +0000</pubDate><guid>https://wnanbei.github.io/post/mysql-%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1%E8%A7%84%E8%8C%83/</guid><description>&lt;p>MySQL 数据库与 Oracle、 SQL Server 等数据库相比，有其内核上的优势与劣势。我们在使用 MySQL 数据库的时候需要遵循一定规范，扬长避短。&lt;/p>
&lt;p>本规范旨在帮助或指导 RD、QA、OP 等技术人员做出适合线上业务的数据库设计。在数据库变更和处理流程、数据库表设计、SQL 编写等方面予以规范，从而为公司业务系统稳定、健康地运行提供保障。&lt;/p></description></item><item><title>MySQL 索引详解</title><link>https://wnanbei.github.io/post/mysql-%E7%B4%A2%E5%BC%95%E8%AF%A6%E8%A7%A3/</link><pubDate>Sat, 06 Feb 2021 00:00:00 +0000</pubDate><guid>https://wnanbei.github.io/post/mysql-%E7%B4%A2%E5%BC%95%E8%AF%A6%E8%A7%A3/</guid><description>&lt;p>索引的出现其实就是为了提高数据查询的效率，就像书的目录一样。&lt;/p></description></item><item><title>MySQL 运算符与数据类型</title><link>https://wnanbei.github.io/post/mysql-%E8%BF%90%E7%AE%97%E7%AC%A6%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</link><pubDate>Sat, 06 Feb 2021 00:00:00 +0000</pubDate><guid>https://wnanbei.github.io/post/mysql-%E8%BF%90%E7%AE%97%E7%AC%A6%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</guid><description>&lt;p>MySQL 常用类型简单介绍如下：&lt;/p>
&lt;p>整数类型：&lt;code>BIT、BOOL、TINY INT、SMALL INT、MEDIUM INT、 INT、 BIG INT&lt;/code>&lt;/p>
&lt;p>浮点数类型：&lt;code>FLOAT、DOUBLE、DECIMAL&lt;/code>&lt;/p>
&lt;p>字符串类型：&lt;code>CHAR、VARCHAR、TINY TEXT、TEXT、MEDIUM TEXT、LONGTEXT、TINY BLOB、BLOB、MEDIUM BLOB、LONG BLOB&lt;/code>&lt;/p>
&lt;p>日期类型：&lt;code>Date、DateTime、TimeStamp、Time、Year&lt;/code>&lt;/p>
&lt;p>其他数据类型：&lt;code>BINARY、VARBINARY、ENUM、SET&lt;/code>&amp;hellip;&lt;/p></description></item><item><title>PostgreSQL 安装与配置</title><link>https://wnanbei.github.io/post/postgresql-%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE/</link><pubDate>Sat, 06 Feb 2021 00:00:00 +0000</pubDate><guid>https://wnanbei.github.io/post/postgresql-%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE/</guid><description/></item><item><title>PostgreSQL 数据库与表</title><link>https://wnanbei.github.io/post/postgresql-%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%8E%E8%A1%A8/</link><pubDate>Sat, 06 Feb 2021 00:00:00 +0000</pubDate><guid>https://wnanbei.github.io/post/postgresql-%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%8E%E8%A1%A8/</guid><description/></item><item><title>Kubernetes 对象</title><link>https://wnanbei.github.io/post/kubernetes-%E5%AF%B9%E8%B1%A1/</link><pubDate>Wed, 06 Jan 2021 16:17:25 +0000</pubDate><guid>https://wnanbei.github.io/post/kubernetes-%E5%AF%B9%E8%B1%A1/</guid><description>&lt;p>Kubernetes 对象指的是 Kubernetes 系统的持久化实体，所有这些对象合起来，代表了集群的实际情况。&lt;/p>
&lt;p>常规的应用里，把应用程序的数据存储在数据库中，Kubernetes 将其数据以对象的形式通过 &lt;code>apiserver&lt;/code> 存储在 &lt;code>etcd&lt;/code> 中。&lt;/p></description></item><item><title>Kubernetes 架构</title><link>https://wnanbei.github.io/post/kubernetes-%E6%9E%B6%E6%9E%84/</link><pubDate>Wed, 06 Jan 2021 16:17:25 +0000</pubDate><guid>https://wnanbei.github.io/post/kubernetes-%E6%9E%B6%E6%9E%84/</guid><description>&lt;p>以下是 k8s 官方的架构图：&lt;/p>
&lt;p>&lt;figure
>
&lt;a href="https://wnanbei.github.io/images/k8s/components-of-kubernetes.png" >
&lt;img src="https://wnanbei.github.io/images/k8s/components-of-kubernetes.png"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/p></description></item><item><title>动态规划之子序列问题</title><link>https://wnanbei.github.io/post/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E4%B9%8B%E5%AD%90%E5%BA%8F%E5%88%97%E9%97%AE%E9%A2%98/</link><pubDate>Sat, 10 Oct 2020 00:00:00 +0000</pubDate><guid>https://wnanbei.github.io/post/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E4%B9%8B%E5%AD%90%E5%BA%8F%E5%88%97%E9%97%AE%E9%A2%98/</guid><description>&lt;p>&lt;strong>子序列&lt;/strong>是指给定一个序列，将给定序列中零个或多个元素去掉之后得到的结果，子序列可以是不连续的。&lt;/p>
&lt;p>一般来说，这类问题都是求一个最长子序列。而一旦涉及到子序列和最值，那几乎可以肯定，考察的是动态规划技巧，时间复杂度一般都是 $O(n^2)$。&lt;/p></description></item><item><title>动态规划之背包问题</title><link>https://wnanbei.github.io/post/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E4%B9%8B%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/</link><pubDate>Sat, 10 Oct 2020 00:00:00 +0000</pubDate><guid>https://wnanbei.github.io/post/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E4%B9%8B%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/</guid><description>&lt;p>背包问题（Knapsack problem）是一种组合优化的NP完全问题。&lt;/p>
&lt;p>问题可以描述为：给定一组物品，每种物品都有自己的重量和价格，在限定的总重量内，我们如何选择，才能使得物品的总价格最高。&lt;/p>
&lt;p>问题的名称来源于如何选择最合适的物品放置于给定背包中。&lt;/p></description></item><item><title>动态规划之贪心算法</title><link>https://wnanbei.github.io/post/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E4%B9%8B%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/</link><pubDate>Sat, 10 Oct 2020 00:00:00 +0000</pubDate><guid>https://wnanbei.github.io/post/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E4%B9%8B%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/</guid><description>&lt;p>贪心算法可以认为是动态规划算法的一个特例，相比动态规划：&lt;/p>
&lt;ul>
&lt;li>使用贪心算法需要满足更多的条件（贪心选择性质）。&lt;/li>
&lt;li>效率比动态规划高。&lt;/li>
&lt;/ul>
&lt;p>一个算法问题使用暴力解法需要指数级时间，如果能使用动态规划消除重叠子问题，就可以降到多项式级别的时间，如果满足贪心选择性质，那么可以进一步降低时间复杂度，达到线性级别。&lt;/p></description></item><item><title>数据结构与算法之二叉搜索树</title><link>https://wnanbei.github.io/post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</link><pubDate>Sat, 10 Oct 2020 00:00:00 +0000</pubDate><guid>https://wnanbei.github.io/post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</guid><description>&lt;p>二叉搜索树 &lt;code>Binary Search Tree&lt;/code> 简称 &lt;code>BST&lt;/code>，是二叉树的一种特殊形式。二叉搜索树每个节点 &lt;code>node&lt;/code> 都具有以下性质：&lt;/p>
&lt;ul>
&lt;li>左子树所有子节点的值都比 &lt;code>node&lt;/code> 的值要小，右子树所有子节点的值都比 &lt;code>node&lt;/code> 的值大。&lt;/li>
&lt;li>它的左侧子树和右侧子树都是 BST。&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>BST 有一个重要的性质: BST 的中序遍历结果是有序的（升序）&lt;/strong>。&lt;/p></description></item><item><title>数据结构与算法之二叉树</title><link>https://wnanbei.github.io/post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E4%BA%8C%E5%8F%89%E6%A0%91/</link><pubDate>Sat, 10 Oct 2020 00:00:00 +0000</pubDate><guid>https://wnanbei.github.io/post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E4%BA%8C%E5%8F%89%E6%A0%91/</guid><description>&lt;p>树是一种经常用到的数据结构，用来模拟具有树状结构性质的数据集合。树里的每一个节点有一个值和一个包含所有子节点的列表。&lt;/p>
&lt;p>从图的观点来看，树也可视为一个拥有 N 个节点和 N-1 条边的一个有向无环图。&lt;/p>
&lt;p>二叉树是一种典型的树状结构，是每个节点最多有两个子树的树结构，通常子树被称作左子树和右子树。&lt;/p></description></item><item><title>数据结构与算法之单链表问题</title><link>https://wnanbei.github.io/post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E5%8D%95%E9%93%BE%E8%A1%A8%E9%97%AE%E9%A2%98/</link><pubDate>Sat, 10 Oct 2020 00:00:00 +0000</pubDate><guid>https://wnanbei.github.io/post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E5%8D%95%E9%93%BE%E8%A1%A8%E9%97%AE%E9%A2%98/</guid><description/></item><item><title>数据结构与算法之常见动态规划问题</title><link>https://wnanbei.github.io/post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E5%B8%B8%E8%A7%81%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E9%97%AE%E9%A2%98/</link><pubDate>Sat, 10 Oct 2020 00:00:00 +0000</pubDate><guid>https://wnanbei.github.io/post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E5%B8%B8%E8%A7%81%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E9%97%AE%E9%A2%98/</guid><description>&lt;p>&lt;strong>动态规划问题的一般形式就是求最值&lt;/strong>。比如求&lt;strong>最长&lt;/strong>递增子序列，&lt;strong>最小&lt;/strong>编辑距离等等。&lt;/p>
&lt;p>&lt;strong>求解动态规划的核心问题是穷举&lt;/strong>。因为要求最值，要把所有可行的答案穷举出来，然后在其中找最值。&lt;/p></description></item><item><title>数据结构与算法之数组</title><link>https://wnanbei.github.io/post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E6%95%B0%E7%BB%84/</link><pubDate>Sat, 10 Oct 2020 00:00:00 +0000</pubDate><guid>https://wnanbei.github.io/post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E6%95%B0%E7%BB%84/</guid><description/></item><item><title>Gin 启动与配置</title><link>https://wnanbei.github.io/post/gin-%E5%90%AF%E5%8A%A8%E4%B8%8E%E9%85%8D%E7%BD%AE/</link><pubDate>Wed, 05 Aug 2020 00:00:00 +0000</pubDate><guid>https://wnanbei.github.io/post/gin-%E5%90%AF%E5%8A%A8%E4%B8%8E%E9%85%8D%E7%BD%AE/</guid><description>&lt;p>Gin 的安装、启动、配置与部分简介。&lt;/p></description></item><item><title>Gin 获取请求数据</title><link>https://wnanbei.github.io/post/gin-%E8%8E%B7%E5%8F%96%E8%AF%B7%E6%B1%82%E6%95%B0%E6%8D%AE/</link><pubDate>Wed, 05 Aug 2020 00:00:00 +0000</pubDate><guid>https://wnanbei.github.io/post/gin-%E8%8E%B7%E5%8F%96%E8%AF%B7%E6%B1%82%E6%95%B0%E6%8D%AE/</guid><description>&lt;p>Gin 获取客户端发送请求的各种路由、URL、Post 表单、header 等数据，或者将这些数据绑定到模型中。&lt;/p></description></item><item><title>Gin 设置 Middleware 中间件</title><link>https://wnanbei.github.io/post/gin-%E8%AE%BE%E7%BD%AE-middleware-%E4%B8%AD%E9%97%B4%E4%BB%B6/</link><pubDate>Wed, 05 Aug 2020 00:00:00 +0000</pubDate><guid>https://wnanbei.github.io/post/gin-%E8%AE%BE%E7%BD%AE-middleware-%E4%B8%AD%E9%97%B4%E4%BB%B6/</guid><description>&lt;p>Gin 设置全局 Middleware、自定义中间件用法。&lt;/p></description></item><item><title>Gin 请求与路由</title><link>https://wnanbei.github.io/post/gin-%E8%AF%B7%E6%B1%82%E4%B8%8E%E8%B7%AF%E7%94%B1/</link><pubDate>Wed, 05 Aug 2020 00:00:00 +0000</pubDate><guid>https://wnanbei.github.io/post/gin-%E8%AF%B7%E6%B1%82%E4%B8%8E%E8%B7%AF%E7%94%B1/</guid><description>&lt;p>Gin 设置请求方式与路由，包括重定向、动态路由、路由分组等。&lt;/p></description></item><item><title>Gin 返回响应方式</title><link>https://wnanbei.github.io/post/gin-%E8%BF%94%E5%9B%9E%E5%93%8D%E5%BA%94%E6%96%B9%E5%BC%8F/</link><pubDate>Wed, 05 Aug 2020 00:00:00 +0000</pubDate><guid>https://wnanbei.github.io/post/gin-%E8%BF%94%E5%9B%9E%E5%93%8D%E5%BA%94%E6%96%B9%E5%BC%8F/</guid><description>&lt;p>Gin 框架在 &lt;code>*gin.Context&lt;/code> 实例中封装了所有处理请求并响应客户端的方法。&lt;/p>
&lt;p>Gin 支持多种响应方法，包括我们常见的 &lt;code>String&lt;/code>、&lt;code>HTML&lt;/code>、&lt;code>JSON&lt;/code>、&lt;code>XML&lt;/code>、&lt;code>YAML&lt;/code>、&lt;code>JSONP&lt;/code>，也支持直接响应 &lt;code>Reader&lt;/code> 和 &lt;code>[]byte&lt;/code>，而且还支持重定向。&lt;/p></description></item><item><title>Gin 配置 Swagger 接口文档</title><link>https://wnanbei.github.io/post/gin-%E9%85%8D%E7%BD%AE-swagger-%E6%8E%A5%E5%8F%A3%E6%96%87%E6%A1%A3/</link><pubDate>Wed, 05 Aug 2020 00:00:00 +0000</pubDate><guid>https://wnanbei.github.io/post/gin-%E9%85%8D%E7%BD%AE-swagger-%E6%8E%A5%E5%8F%A3%E6%96%87%E6%A1%A3/</guid><description>&lt;p>此包用于自动化生成 API 文档。&lt;/p></description></item><item><title>Gin 高级功能</title><link>https://wnanbei.github.io/post/gin-%E9%AB%98%E7%BA%A7%E5%8A%9F%E8%83%BD/</link><pubDate>Wed, 05 Aug 2020 00:00:00 +0000</pubDate><guid>https://wnanbei.github.io/post/gin-%E9%AB%98%E7%BA%A7%E5%8A%9F%E8%83%BD/</guid><description>&lt;p>Gin 提供的日志功能和部分其他功能，包括：优雅关闭或重启、提供静态文件、http2 服务推送、自定义验证器、设置和获取 Cookies、从 reader 提供数据。&lt;/p></description></item><item><title>Go 上下文 context</title><link>https://wnanbei.github.io/post/go-%E4%B8%8A%E4%B8%8B%E6%96%87-context/</link><pubDate>Fri, 05 Jun 2020 00:00:00 +0000</pubDate><guid>https://wnanbei.github.io/post/go-%E4%B8%8A%E4%B8%8B%E6%96%87-context/</guid><description>&lt;p>context 指的是上下文，以下是几种 ctx 类型:&lt;/p>
&lt;ul>
&lt;li>emptyCtx - 所有 ctx 类型的根，用 &lt;code>context.TODO()&lt;/code>，或 &lt;code>context.Background()&lt;/code> 来生成。&lt;/li>
&lt;li>valueCtx - 主要就是为了在 ctx 中嵌入上下文数据，一个简单的 k 和 v 结构，同一个 ctx 内只支持一对 kv，需要更多的 kv 的话，会形成一棵树形结构。&lt;/li>
&lt;li>cancelCtx - 用来取消程序的执行树，一般用 &lt;code>WithCancel&lt;/code>，&lt;code>WithTimeout&lt;/code>，&lt;code>WithDeadline&lt;/code> 返回的取消函数本质上都是对应了 cancelCtx。&lt;/li>
&lt;li>timerCtx - 在 cancelCtx 上包了一层，支持基于时间的 cancel。&lt;/li>
&lt;/ul></description></item><item><title>Go 反射 reflect</title><link>https://wnanbei.github.io/post/go-%E5%8F%8D%E5%B0%84-reflect/</link><pubDate>Fri, 05 Jun 2020 00:00:00 +0000</pubDate><guid>https://wnanbei.github.io/post/go-%E5%8F%8D%E5%B0%84-reflect/</guid><description>&lt;p>反射是程序在运行期间检查其自身结构的一种方式 。&lt;/p>
&lt;p>反射三大法则：&lt;/p>
&lt;ul>
&lt;li>反射可以将&lt;code>接口类型变量&lt;/code>转换为&lt;code>反射类型对象&lt;/code>&lt;/li>
&lt;li>反射可以将&lt;code>反射类型对象&lt;/code>转换为&lt;code>接口类型变量&lt;/code>&lt;/li>
&lt;li>如果要修改&lt;code>反射类型对象&lt;/code>，其值必须是&lt;code>可写的(settable)&lt;/code>&lt;/li>
&lt;/ul></description></item><item><title>Go 日志打印 fmt</title><link>https://wnanbei.github.io/post/go-%E6%97%A5%E5%BF%97%E6%89%93%E5%8D%B0-fmt/</link><pubDate>Fri, 05 Jun 2020 00:00:00 +0000</pubDate><guid>https://wnanbei.github.io/post/go-%E6%97%A5%E5%BF%97%E6%89%93%E5%8D%B0-fmt/</guid><description>&lt;p>&lt;code>fmt&lt;/code> 是 Go 用于日志打印的库：&lt;/p>
&lt;ul>
&lt;li>模板模式: &lt;code>[name]f&lt;/code> 根据模板格式化 例如: &lt;code>Printf&lt;/code>&lt;/li>
&lt;li>换行模式: &lt;code>[name]ln&lt;/code> 输出后带换行 例如: &lt;code>Println&lt;/code>&lt;/li>
&lt;/ul></description></item><item><title>Go 时间处理库 time</title><link>https://wnanbei.github.io/post/go-%E6%97%B6%E9%97%B4%E5%A4%84%E7%90%86%E5%BA%93-time/</link><pubDate>Fri, 05 Jun 2020 00:00:00 +0000</pubDate><guid>https://wnanbei.github.io/post/go-%E6%97%B6%E9%97%B4%E5%A4%84%E7%90%86%E5%BA%93-time/</guid><description>&lt;p>time 是 Go 用于处理时间的标准库，包括格式化、计算、修改、定时、超时等功能。&lt;/p></description></item><item><title>Go 错误处理 errors</title><link>https://wnanbei.github.io/post/go-%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86-errors/</link><pubDate>Fri, 05 Jun 2020 00:00:00 +0000</pubDate><guid>https://wnanbei.github.io/post/go-%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86-errors/</guid><description>&lt;p>&lt;code>errors&lt;/code> 用于增强 Go 的错误处理能力。&lt;/p></description></item><item><title>Go 系统库 os</title><link>https://wnanbei.github.io/post/go-%E7%B3%BB%E7%BB%9F%E5%BA%93-os/</link><pubDate>Tue, 05 May 2020 00:00:00 +0000</pubDate><guid>https://wnanbei.github.io/post/go-%E7%B3%BB%E7%BB%9F%E5%BA%93-os/</guid><description>&lt;p>&lt;code>os&lt;/code> 库主要用于 Go 的文件、系统相关操作。&lt;/p></description></item><item><title>Go 基础数据结构</title><link>https://wnanbei.github.io/post/go-%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</link><pubDate>Fri, 01 Nov 2019 00:00:00 +0000</pubDate><guid>https://wnanbei.github.io/post/go-%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</guid><description>&lt;p>Go 基础数据结构 &lt;code>array&lt;/code>、&lt;code>slice&lt;/code>、&lt;code>map&lt;/code> 的声明与使用。&lt;/p></description></item><item><title>Go 并发消息队列 channel</title><link>https://wnanbei.github.io/post/go-%E5%B9%B6%E5%8F%91%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97-channel/</link><pubDate>Fri, 01 Nov 2019 00:00:00 +0000</pubDate><guid>https://wnanbei.github.io/post/go-%E5%B9%B6%E5%8F%91%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97-channel/</guid><description>&lt;p>&lt;code>Channel&lt;/code> 实际上是类型化消息的队列，它有以下特性：&lt;/p>
&lt;ul>
&lt;li>只能传输一种类型的数据。&lt;/li>
&lt;li>所有的类型都可以用于通道，空接口 &lt;code>interface{}&lt;/code> 也可以。&lt;/li>
&lt;li>先进先出 &lt;code>FIFO&lt;/code> 的结构。&lt;/li>
&lt;li>引用类型，所以使用 &lt;code>make()&lt;/code> 函数来给它分配内存。&lt;/li>
&lt;/ul></description></item><item><title>Go 结构体 struct</title><link>https://wnanbei.github.io/post/go-%E7%BB%93%E6%9E%84%E4%BD%93-struct/</link><pubDate>Fri, 01 Nov 2019 00:00:00 +0000</pubDate><guid>https://wnanbei.github.io/post/go-%E7%BB%93%E6%9E%84%E4%BD%93-struct/</guid><description>&lt;p>Go 通过类型别名 &lt;code>alias types&lt;/code> 和结构体的形式支持用户自定义类型。&lt;/p></description></item><item><title>Go interface 接口</title><link>https://wnanbei.github.io/post/go-interface-%E6%8E%A5%E5%8F%A3/</link><pubDate>Tue, 01 Oct 2019 00:00:00 +0000</pubDate><guid>https://wnanbei.github.io/post/go-interface-%E6%8E%A5%E5%8F%A3/</guid><description>&lt;p>interface 的一些特性：&lt;/p>
&lt;ul>
&lt;li>类型不需要显式声明它实现了某个接口：接口被隐式地实现。&lt;/li>
&lt;li>多个类型可以实现同一个接口。&lt;/li>
&lt;li>实现某个接口的类型，除了实现接口方法外，可以有其他的方法。&lt;/li>
&lt;li>一个类型可以实现多个接口。&lt;/li>
&lt;li>接口是动态类型，可以包含一个实例的引用，该实例的类型实现了此接口。&lt;/li>
&lt;li>即使接口在类型之后才定义，二者处于不同的包中，被单独编译，只要类型实现了接口中的方法，它就实现了此接口。&lt;/li>
&lt;li>接口只能访问接口内声明的方法。&lt;/li>
&lt;/ul></description></item><item><title>Go 包管理 Package</title><link>https://wnanbei.github.io/post/go-%E5%8C%85%E7%AE%A1%E7%90%86-package/</link><pubDate>Thu, 01 Aug 2019 00:00:00 +0000</pubDate><guid>https://wnanbei.github.io/post/go-%E5%8C%85%E7%AE%A1%E7%90%86-package/</guid><description>&lt;p>Go 使用包结构 package 来定义模块、组织代码。&lt;/p></description></item><item><title>Go 流程控制语句</title><link>https://wnanbei.github.io/post/go-%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5/</link><pubDate>Fri, 01 Feb 2019 00:00:00 +0000</pubDate><guid>https://wnanbei.github.io/post/go-%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5/</guid><description>&lt;p>Go 的流程控制语句，包括 &lt;code>if&lt;/code>、&lt;code>switch&lt;/code>、&lt;code>for&lt;/code>。&lt;/p></description></item><item><title>Go net/http client 客户端</title><link>https://wnanbei.github.io/post/go-net/http-client-%E5%AE%A2%E6%88%B7%E7%AB%AF/</link><pubDate>Tue, 01 Jan 2019 00:00:00 +0000</pubDate><guid>https://wnanbei.github.io/post/go-net/http-client-%E5%AE%A2%E6%88%B7%E7%AB%AF/</guid><description>&lt;p>Go 中的&lt;code>net&lt;/code>包封装了大部分网络相关的功能，我们基本不需要借助其他库就能实现我们的爬虫需求。&lt;/p></description></item><item><title>Go 函数</title><link>https://wnanbei.github.io/post/go-%E5%87%BD%E6%95%B0/</link><pubDate>Tue, 01 Jan 2019 00:00:00 +0000</pubDate><guid>https://wnanbei.github.io/post/go-%E5%87%BD%E6%95%B0/</guid><description>&lt;p>除了 &lt;code>main()&lt;/code>、&lt;code>init()&lt;/code> 函数外，其它所有类型的函数都可以有参数与返回值。&lt;/p>
&lt;p>函数参数、返回值以及它们的类型被统称为函数签名。&lt;/p></description></item><item><title>Go 语言规范</title><link>https://wnanbei.github.io/post/go-%E8%AF%AD%E8%A8%80%E8%A7%84%E8%8C%83/</link><pubDate>Tue, 01 Jan 2019 00:00:00 +0000</pubDate><guid>https://wnanbei.github.io/post/go-%E8%AF%AD%E8%A8%80%E8%A7%84%E8%8C%83/</guid><description>&lt;p>Go 语言规范指导性原则：&lt;/p>
&lt;ol>
&lt;li>简单性&lt;/li>
&lt;li>可读性&lt;/li>
&lt;li>生产力&lt;/li>
&lt;/ol></description></item><item><title>HTTP网络协议</title><link>https://wnanbei.github.io/post/http%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/</link><pubDate>Sat, 06 Jan 2018 16:17:25 +0000</pubDate><guid>https://wnanbei.github.io/post/http%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/</guid><description>&lt;p>&lt;code>HTTP（HyperText Transfer Protocol）&lt;/code>，意为超文本传输协议，是目前互联网上应用最为广泛的一种网络协议。目前使用最普遍的一个版本是HTTP 1.1。&lt;/p></description></item><item><title>TCP/IP传输层网络协议</title><link>https://wnanbei.github.io/post/tcp/ip%E4%BC%A0%E8%BE%93%E5%B1%82%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/</link><pubDate>Sat, 06 Jan 2018 16:17:25 +0000</pubDate><guid>https://wnanbei.github.io/post/tcp/ip%E4%BC%A0%E8%BE%93%E5%B1%82%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/</guid><description>&lt;p>&lt;strong>其实网络协议，就是为了所有的计算机能够在同一个网络中互相传递数据，而制定的数据传输规则。&lt;/strong> 就好像我们只有说同一种语言才能互相交流一个道理，那么想要在互联网中传递数据，就得遵守标准的网络协议。&lt;/p></description></item></channel></rss>