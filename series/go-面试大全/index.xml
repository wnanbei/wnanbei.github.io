<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Go 面试大全 on WNANBEI</title><link>https://wnanbei.github.io/series/go-%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8/</link><description>Recent content in Go 面试大全 on WNANBEI</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Mon, 25 Oct 2021 00:00:00 +0000</lastBuildDate><atom:link href="https://wnanbei.github.io/series/go-%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8/index.xml" rel="self" type="application/rss+xml"/><item><title>Go 令牌桶限流器 golang.org/x/time/rate</title><link>https://wnanbei.github.io/post/go-%E4%BB%A4%E7%89%8C%E6%A1%B6%E9%99%90%E6%B5%81%E5%99%A8-golang.org/x/time/rate/</link><pubDate>Mon, 25 Oct 2021 00:00:00 +0000</pubDate><guid>https://wnanbei.github.io/post/go-%E4%BB%A4%E7%89%8C%E6%A1%B6%E9%99%90%E6%B5%81%E5%99%A8-golang.org/x/time/rate/</guid><description>&lt;p>&lt;code>golang.org/x/time/rate&lt;/code> 提供了一个使用令牌桶 &lt;code>Token Bucket&lt;/code> 算法实现的限流器。&lt;/p></description></item><item><title>CSP 并发编程模型</title><link>https://wnanbei.github.io/post/csp-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E6%A8%A1%E5%9E%8B/</link><pubDate>Thu, 05 Aug 2021 00:00:00 +0000</pubDate><guid>https://wnanbei.github.io/post/csp-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E6%A8%A1%E5%9E%8B/</guid><description>&lt;p>&lt;code>CSP - Communicating Sequential Process&lt;/code>，通信顺序进程，是一种并发编程模型，用于描述两个独立的并发实体通过共享的通讯 channel 进行通信。&lt;/p></description></item><item><title>Go GC 垃圾回收</title><link>https://wnanbei.github.io/post/go-gc-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/</link><pubDate>Thu, 05 Aug 2021 00:00:00 +0000</pubDate><guid>https://wnanbei.github.io/post/go-gc-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/</guid><description>&lt;p>垃圾回收 - &lt;code>GC&lt;/code> - &lt;code>garbage collection&lt;/code> 是自动内存管理的一种形式。通常由垃圾收集器收集并适时回收或重用不再被对象占用的内存。&lt;/p>
&lt;p>垃圾回收作为内存管理的一部分，包含 3 个重要的功能：&lt;/p>
&lt;ul>
&lt;li>如何分配和管理新对象。&lt;/li>
&lt;li>如何识别正在使用中的对象。&lt;/li>
&lt;li>如何清除不再使用的对象。&lt;/li>
&lt;/ul></description></item><item><title>Go GMP 调度器</title><link>https://wnanbei.github.io/post/go-gmp-%E8%B0%83%E5%BA%A6%E5%99%A8/</link><pubDate>Sun, 01 Aug 2021 00:00:00 +0000</pubDate><guid>https://wnanbei.github.io/post/go-gmp-%E8%B0%83%E5%BA%A6%E5%99%A8/</guid><description>&lt;p>GMP Scheduler 是 Runtime 中几乎最重要的组件，它的作用是：&lt;/p>
&lt;blockquote>
&lt;p>For scheduling goroutines onto kernel threads.&lt;/p>
&lt;/blockquote>
&lt;p>GMP Scheduler 的核心思想是：&lt;/p>
&lt;ol>
&lt;li>重用线程。&lt;/li>
&lt;li>限制同时运行（不包含阻塞）的线程数为 N，N 为 CPU 逻辑核心数。&lt;/li>
&lt;/ol>
&lt;p>Go scheduler 的职责就是将所有处于 runnable 的 Goroutines 均匀分布到在 P 上运行的 M，利用多核并行，实现更强大的并发。&lt;/p></description></item><item><title>Go 互斥锁 sync.Mutex</title><link>https://wnanbei.github.io/post/go-%E4%BA%92%E6%96%A5%E9%94%81-sync.mutex/</link><pubDate>Wed, 05 May 2021 00:00:00 +0000</pubDate><guid>https://wnanbei.github.io/post/go-%E4%BA%92%E6%96%A5%E9%94%81-sync.mutex/</guid><description>&lt;p>&lt;code>sync.Mutex&lt;/code> 是一个互斥锁，默认为零值时为开锁状态。&lt;/p></description></item><item><title>Go 原子操作 atomic</title><link>https://wnanbei.github.io/post/go-%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C-atomic/</link><pubDate>Wed, 05 May 2021 00:00:00 +0000</pubDate><guid>https://wnanbei.github.io/post/go-%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C-atomic/</guid><description>&lt;p>&lt;code>atomic&lt;/code> 包封装了系统底层的原子操作。官方建议尽量少使用此包的原子操作，尽量遵循通过通信分享内存，而不是通过分享内存来通信的原则。&lt;/p>
&lt;p>这个包的方法有以下特点：&lt;/p>
&lt;ul>
&lt;li>方法操作的都是 &lt;code>int&lt;/code> 系列类型或指针。&lt;/li>
&lt;li>操作的数据需要其地址。&lt;/li>
&lt;/ul></description></item><item><title>Go 对象池 sync.Pool</title><link>https://wnanbei.github.io/post/go-%E5%AF%B9%E8%B1%A1%E6%B1%A0-sync.pool/</link><pubDate>Wed, 05 May 2021 00:00:00 +0000</pubDate><guid>https://wnanbei.github.io/post/go-%E5%AF%B9%E8%B1%A1%E6%B1%A0-sync.pool/</guid><description>&lt;p>sync.Pool 是一个协程安全的内存池。主要用于增加临时对象的内存复用率，减少内存分配和 GC STW 的开销。、&lt;/p></description></item><item><title>Go 并发安全的 sync.Map</title><link>https://wnanbei.github.io/post/go-%E5%B9%B6%E5%8F%91%E5%AE%89%E5%85%A8%E7%9A%84-sync.map/</link><pubDate>Wed, 05 May 2021 00:00:00 +0000</pubDate><guid>https://wnanbei.github.io/post/go-%E5%B9%B6%E5%8F%91%E5%AE%89%E5%85%A8%E7%9A%84-sync.map/</guid><description>&lt;p>&lt;code>sync.Map&lt;/code> 是标准库 &lt;code>sync&lt;/code> 中实现的并发安全的 map。&lt;/p></description></item><item><title>Go 标准库 sync.WaitGroup</title><link>https://wnanbei.github.io/post/go-%E6%A0%87%E5%87%86%E5%BA%93-sync.waitgroup/</link><pubDate>Wed, 05 May 2021 00:00:00 +0000</pubDate><guid>https://wnanbei.github.io/post/go-%E6%A0%87%E5%87%86%E5%BA%93-sync.waitgroup/</guid><description/></item><item><title>Go 读写锁 sync.RWMutex</title><link>https://wnanbei.github.io/post/go-%E8%AF%BB%E5%86%99%E9%94%81-sync.rwmutex/</link><pubDate>Wed, 05 May 2021 00:00:00 +0000</pubDate><guid>https://wnanbei.github.io/post/go-%E8%AF%BB%E5%86%99%E9%94%81-sync.rwmutex/</guid><description>&lt;p>&lt;code>sync.RWMutex&lt;/code> 是一个读写锁，在读多写少的场景中，比 Mutex 的并发能力有很大的提升。&lt;/p></description></item><item><title>Go 上下文 context</title><link>https://wnanbei.github.io/post/go-%E4%B8%8A%E4%B8%8B%E6%96%87-context/</link><pubDate>Fri, 05 Jun 2020 00:00:00 +0000</pubDate><guid>https://wnanbei.github.io/post/go-%E4%B8%8A%E4%B8%8B%E6%96%87-context/</guid><description>&lt;p>context 指的是上下文，以下是几种 ctx 类型:&lt;/p>
&lt;ul>
&lt;li>emptyCtx - 所有 ctx 类型的根，用 &lt;code>context.TODO()&lt;/code>，或 &lt;code>context.Background()&lt;/code> 来生成。&lt;/li>
&lt;li>valueCtx - 主要就是为了在 ctx 中嵌入上下文数据，一个简单的 k 和 v 结构，同一个 ctx 内只支持一对 kv，需要更多的 kv 的话，会形成一棵树形结构。&lt;/li>
&lt;li>cancelCtx - 用来取消程序的执行树，一般用 &lt;code>WithCancel&lt;/code>，&lt;code>WithTimeout&lt;/code>，&lt;code>WithDeadline&lt;/code> 返回的取消函数本质上都是对应了 cancelCtx。&lt;/li>
&lt;li>timerCtx - 在 cancelCtx 上包了一层，支持基于时间的 cancel。&lt;/li>
&lt;/ul></description></item><item><title>Go 并发消息队列 channel</title><link>https://wnanbei.github.io/post/go-%E5%B9%B6%E5%8F%91%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97-channel/</link><pubDate>Fri, 01 Nov 2019 00:00:00 +0000</pubDate><guid>https://wnanbei.github.io/post/go-%E5%B9%B6%E5%8F%91%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97-channel/</guid><description>&lt;p>&lt;code>Channel&lt;/code> 实际上是类型化消息的队列，它有以下特性：&lt;/p>
&lt;ul>
&lt;li>只能传输一种类型的数据。&lt;/li>
&lt;li>所有的类型都可以用于通道，空接口 &lt;code>interface{}&lt;/code> 也可以。&lt;/li>
&lt;li>先进先出 &lt;code>FIFO&lt;/code> 的结构。&lt;/li>
&lt;li>引用类型，所以使用 &lt;code>make()&lt;/code> 函数来给它分配内存。&lt;/li>
&lt;/ul></description></item></channel></rss>